<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>winafl中基于插桩的覆盖率反馈原理 | riusksk&#39;s blog</title>
  <meta name="author" content="riusksk" />

  
  <meta name="description" content="最近winafl增加支持对Intel PT的支持的，但是只支持x64，且覆盖率计算不全，比如条件跳转等，所以它现在还是不如直接用插桩去hook的方式来得准确完整，这里主要想分析也是基于    DynamoRIO插桩的覆盖率反馈原理。
之前曾有人在《初识 Fuzzing 工具 WinAFL》（http" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="winafl中基于插桩的覆盖率反馈原理" />
  <meta property="og:site_name" content="riusksk&#39;s blog" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="riusksk&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78773323-1', 'auto');
	ga('send', 'pageview');

</script>



  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">riusksk&#39;s blog</a></h1>
  <h2><a href="/">攀蟾折桂摄寰宇，摘星揽月御乾坤。踏云踩雾骋宵壤，驱风逐日闯天地。 ------泉哥</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/atom.xml">RSS订阅</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2019-02-02T09:07:54.000Z"><a href="/2019/02/02/winafl中基于插桩的覆盖率反馈原理/">2019-02-02</a></time>
      
      
  
    <h1 class="title">winafl中基于插桩的覆盖率反馈原理</h1>
  

    </header>
    <div class="entry">
      
        <p>最近<code>winafl</code>增加支持对<code>Intel PT</code>的支持的，但是只支持<code>x64</code>，且覆盖率计算不全，比如条件跳转等，所以它现在还是不如直接用插桩去hook的方式来得准确完整，这里主要想分析也是基于    <code>DynamoRIO</code>插桩的覆盖率反馈原理。</p>
<p>之前曾有人在《初识 Fuzzing 工具 WinAFL》（<a href="https://paper.seebug.org/323/#32）中“3.2.2" target="_blank" rel="external">https://paper.seebug.org/323/#32）中“3.2.2</a> 插桩模块”一节中简单分析过其插桩原理，但没有找到我想要的答案，因此只好自动动手分析下源码。</p>
<p>比如，我想知道：</p>
<ol>
<li><p>通过循环调用fuzzing的目标函数来提高速度，但<code>DynamoRIO</code>的覆盖率信息是如何同步给fuzzer主进程的？</p>
</li>
<li><p>具体是如何实现寄存器环境的记录与恢复，从而实现目标函数的不断循环？</p>
</li>
<li><p>覆盖率信息是如何记录与分析的？</p>
</li>
</ol>
<h4 id="覆盖率信息记录与分析原理"><a href="#覆盖率信息记录与分析原理" class="headerlink" title="覆盖率信息记录与分析原理"></a>覆盖率信息记录与分析原理</h4><p>第3个问题发现已经有人分析过<code>afl</code>，可以参见这里《AFL内部实现细节小记》（<a href="http://rk700.github.io/2017/12/28/afl-internals/），简单总结下" target="_blank" rel="external">http://rk700.github.io/2017/12/28/afl-internals/），简单总结下</a>:</p>
<ol>
<li><p>AFL在编译源码时，为每个代码生成一个随机数，代表位置地址;</p>
</li>
<li><p>在二元组中记录分支跳转的源地址与目标地址，将两者异或的结果为该分支的key，保存每个分支的执行次数，用1字节来储存；</p>
</li>
<li><p>保存分支的执行次数实际上是一张大小为64K的哈希表，位于共享内存中，方便target进程与fuzzer进程之间共享，对应的伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>fuzzer进程通过buckets哈希桶来归类这些分支执行次数，如下结构定义，左边为执行次数，右边为记录值trace_bits：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> u8 count_class_lookup8[<span class="number">256</span>] = &#123;</span><br><span class="line">  [<span class="number">0</span>]           = <span class="number">0</span>, </span><br><span class="line">  [<span class="number">1</span>]           = <span class="number">1</span>, </span><br><span class="line">  [<span class="number">2</span>]           = <span class="number">2</span>, </span><br><span class="line">  [<span class="number">3</span>]           = <span class="number">4</span>, </span><br><span class="line">  [<span class="number">4</span> ... <span class="number">7</span>]     = <span class="number">8</span>, </span><br><span class="line">  [<span class="number">8</span> ... <span class="number">15</span>]    = <span class="number">16</span>,</span><br><span class="line">  [<span class="number">16</span> ... <span class="number">31</span>]   = <span class="number">32</span>,</span><br><span class="line">  [<span class="number">32</span> ... <span class="number">127</span>]  = <span class="number">64</span>,</span><br><span class="line">  [<span class="number">128</span> ... <span class="number">255</span>] = <span class="number">128</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于是否触发新路径，主要通过计算各分支的trace_bits的hash值（算法：<code>u32 cksum **=** hash32(trace_bits, MAP_SIZE常量, HASH_CONST常量);</code>）是否发生变化来实现的</p>
</li>
</ol>
<h4 id="覆盖信息的传递原理"><a href="#覆盖信息的传递原理" class="headerlink" title="覆盖信息的传递原理"></a>覆盖信息的传递原理</h4><ol>
<li><p>先在fuzzer进程中先创建命名管道，其中fuzzer_id为随机值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c</span></span><br><span class="line"> pipe_name = (<span class="keyword">char</span> *)alloc_printf(<span class="string">"\\\\.\\pipe\\afl_pipe_%s"</span>, fuzzer_id);</span><br><span class="line">   </span><br><span class="line"> pipe_handle = CreateNamedPipe(</span><br><span class="line">   pipe_name,                <span class="comment">// pipe name</span></span><br><span class="line">PIPE_ACCESS_DUPLEX |     <span class="comment">// read/write access </span></span><br><span class="line">FILE_FLAG_OVERLAPPED,    <span class="comment">// overlapped mode </span></span><br><span class="line">   <span class="number">0</span>,</span><br><span class="line">   <span class="number">1</span>,                        <span class="comment">// max. instances</span></span><br><span class="line">   <span class="number">512</span>,                      <span class="comment">// output buffer size</span></span><br><span class="line">   <span class="number">512</span>,                      <span class="comment">// input buffer size</span></span><br><span class="line">   <span class="number">20000</span>,                    <span class="comment">// client time-out</span></span><br><span class="line">   <span class="literal">NULL</span>);                    <span class="comment">// default security attribute</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建drrun进程去运行目标程序并Hook，在childpid_(%fuzzer_id%).txt的文件中记录子进程id，即目标进程ID，然后等待管道连接，并通过读取上述txt文件以获取目标进程id，主要用来后面超时中断进程的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//afl-fuzz.c    </span></span><br><span class="line">    pidfile = alloc_printf(<span class="string">"childpid_%s.txt"</span>, fuzzer_id);</span><br><span class="line">	<span class="keyword">if</span> (persist_dr_cache) &#123;</span><br><span class="line">		cmd = alloc_printf(</span><br><span class="line">			<span class="string">"%s\\drrun.exe -pidfile %s -no_follow_children -persist -persist_dir \"%s\\drcache\" -c winafl.dll %s -fuzzer_id %s -drpersist -- %s"</span>,</span><br><span class="line">			dynamorio_dir, pidfile, out_dir, client_params, fuzzer_id, target_cmd);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		cmd = alloc_printf(</span><br><span class="line">			<span class="string">"%s\\drrun.exe -pidfile %s -no_follow_children -c winafl.dll %s -fuzzer_id %s -- %s"</span>,</span><br><span class="line">			dynamorio_dir, pidfile, client_params, fuzzer_id, target_cmd);</span><br><span class="line">	&#125;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span>(!CreateProcess(<span class="literal">NULL</span>, cmd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, inherit_handles, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi)) &#123;</span><br><span class="line">    FATAL(<span class="string">"CreateProcess failed, GLE=%d.\n"</span>, GetLastError());</span><br><span class="line">  &#125;</span><br><span class="line">......</span><br><span class="line">      <span class="keyword">if</span>(!OverlappedConnectNamedPipe(pipe_handle, &amp;pipe_overlapped)) &#123;</span><br><span class="line">      FATAL(<span class="string">"ConnectNamedPipe failed, GLE=%d.\n"</span>, GetLastError());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  watchdog_enabled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(drioless == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//by the time pipe has connected the pidfile must have been created</span></span><br><span class="line">    fp = fopen(pidfile, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!fp) &#123;</span><br><span class="line">      FATAL(<span class="string">"Error opening pidfile.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    pidsize = ftell(fp);</span><br><span class="line">    fseek(fp,<span class="number">0</span>,SEEK_SET);</span><br><span class="line">    buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(pidsize+<span class="number">1</span>);</span><br><span class="line">    fread(buf, pidsize, <span class="number">1</span>, fp);</span><br><span class="line">    buf[pidsize] = <span class="number">0</span>;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    remove(pidfile);</span><br><span class="line">    child_pid = atoi(buf);</span><br><span class="line">    <span class="built_in">free</span>(buf);</span><br><span class="line">    ck_free(pidfile);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    child_pid = pi.dwProcessId;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在插桩模块winafl.dll中打开前面创建的命名管道，然后通过管道与fuzzer主进程进行交互：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//winafl.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">setup_pipe() &#123;</span><br><span class="line">    pipe = CreateFile(</span><br><span class="line">         options.pipe_name,   <span class="comment">// pipe name</span></span><br><span class="line">         GENERIC_READ |  <span class="comment">// read and write access</span></span><br><span class="line">         GENERIC_WRITE,</span><br><span class="line">         <span class="number">0</span>,              <span class="comment">// no sharing</span></span><br><span class="line">         <span class="literal">NULL</span>,           <span class="comment">// default security attributes</span></span><br><span class="line">         OPEN_EXISTING,  <span class="comment">// opens existing pipe</span></span><br><span class="line">         <span class="number">0</span>,              <span class="comment">// default attributes</span></span><br><span class="line">         <span class="literal">NULL</span>);          <span class="comment">// no template file</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pipe == INVALID_HANDLE_VALUE) DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"error connecting to pipe"</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">ReadCommandFromPipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD num_read;</span><br><span class="line">	<span class="keyword">char</span> result;</span><br><span class="line">	ReadFile(pipe, &amp;result, <span class="number">1</span>, &amp;num_read, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WriteCommandToPipe</span><span class="params">(<span class="keyword">char</span> cmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DWORD num_written;</span><br><span class="line">	WriteFile(pipe, &amp;cmd, <span class="number">1</span>, &amp;num_written, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当插桩模块winafl.dll监测到程序首次运行至目标函数入口时，<code>pre_fuzz_handler</code>函数会被执行，然后通过管道写入’P’命令，代表开始进入目标函数，afl-fuzz.exe进程收到命令后，会向目标进程写入管道命令’F’，并监测超时时间和循环调用次数。afl-fuzz.exe与目标进程正是通过读写管道命令来交互的，主要有’F’（退出目标函数）、’P’（进入目标函数）、’K’（超时中断进程）、’C’（崩溃）、’Q’（退出进程）。覆盖信息通过文件映射方法（内存共享）写入<code>winafl_data.afl_area</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//winafl.c</span></span><br><span class="line">pre_fuzz_handler(<span class="keyword">void</span> *wrapcxt, INOUT <span class="keyword">void</span> **user_data)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span>(!options.debug_mode) &#123;</span><br><span class="line">		WriteCommandToPipe(<span class="string">'P'</span>);</span><br><span class="line">		command = ReadCommandFromPipe();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(command != <span class="string">'F'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(command == <span class="string">'Q'</span>) &#123;</span><br><span class="line">                dr_exit_process(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"unrecognized command received over pipe"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debug_data.pre_hanlder_called++;</span><br><span class="line">        dr_fprintf(winafl_data.<span class="built_in">log</span>, <span class="string">"In pre_fuzz_handler\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    <span class="built_in">memset</span>(winafl_data.afl_area, <span class="number">0</span>, MAP_SIZE);	<span class="comment">// 用于存储覆盖率信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(options.coverage_kind == COVERAGE_EDGE || options.thread_coverage) &#123;</span><br><span class="line">        <span class="keyword">void</span> **thread_data = (<span class="keyword">void</span> **)drmgr_get_tls_field(drcontext, winafl_tls_field);</span><br><span class="line">        thread_data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        thread_data[<span class="number">1</span>] = winafl_data.afl_area;	<span class="comment">//如果开启-thread_coverage选项，则会将覆盖率信息写入线程TLS中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//winafl.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">setup_shmem() &#123;</span><br><span class="line">   HANDLE map_file;</span><br><span class="line"></span><br><span class="line">   map_file = OpenFileMapping(</span><br><span class="line">                   FILE_MAP_ALL_ACCESS,   <span class="comment">// read/write access</span></span><br><span class="line">                   FALSE,                 <span class="comment">// do not inherit the name</span></span><br><span class="line">                   options.shm_name);     <span class="comment">// name of mapping object</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (map_file == <span class="literal">NULL</span>) DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"error accesing shared memory"</span>);</span><br><span class="line"></span><br><span class="line">   winafl_data.afl_area = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) MapViewOfFile(map_file, <span class="comment">// handle to map object</span></span><br><span class="line">               FILE_MAP_ALL_ACCESS,  <span class="comment">// read/write permission</span></span><br><span class="line">               <span class="number">0</span>,</span><br><span class="line">               <span class="number">0</span>,</span><br><span class="line">               MAP_SIZE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (winafl_data.afl_area == <span class="literal">NULL</span>) DR_ASSERT_MSG(<span class="literal">false</span>, <span class="string">"error accesing shared memory"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="篡改目标函数循环调用的原理"><a href="#篡改目标函数循环调用的原理" class="headerlink" title="篡改目标函数循环调用的原理"></a>篡改目标函数循环调用的原理</h3><p>此步的关键就在于进入目标函数前调用的<code>pre_fuzz_handler</code>函数，以及函数退出后调用的<code>post_fuzz_handler</code>函数。</p>
<p>进入<code>pre_fuzz_handler</code>函数时，winafl.dll会先获取以下信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app_pc target_to_fuzz = drwrap_get_func(wrapcxt);	<span class="comment">//获取目标函数地址</span></span><br><span class="line"><span class="keyword">dr_mcontext_t</span> *mc = drwrap_get_mcontext_ex(wrapcxt, DR_MC_ALL);	<span class="comment">//获取目标函数当前内存上下文信息</span></span><br><span class="line">drcontext = drwrap_get_drcontext(wrapcxt);	<span class="comment">//获取DynamoRIO上下文</span></span><br><span class="line"></span><br><span class="line">fuzz_target.xsp = mc-&gt;xsp;	<span class="comment">// 保存栈指针,xsp是各平台下的通用标记变量</span></span><br><span class="line">fuzz_target.func_pc = target_to_fuzz;	<span class="comment">// 目标函数地址</span></span><br></pre></td></tr></table></figure>
<p>其中内存上下文信息支持各平台的寄存器记录：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">dr_mcontext_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of this structure.  This field must be set prior to filling</span></span><br><span class="line"><span class="comment">     * in the fields to support forward compatibility.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The valid fields of this structure.  This field must be set prior to</span></span><br><span class="line"><span class="comment">     * filling in the fields.  For input requests (dr_get_mcontext()), this</span></span><br><span class="line"><span class="comment">     * indicates which fields should be written.  Writing the multimedia fields</span></span><br><span class="line"><span class="comment">     * frequently can incur a performance hit.  For output requests</span></span><br><span class="line"><span class="comment">     * (dr_set_mcontext() and dr_redirect_execution()), this indicates which</span></span><br><span class="line"><span class="comment">     * fields will be copied to the actual context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">dr_mcontext_flags_t</span> flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AARCHXX</span></span><br><span class="line">    <span class="keyword">reg_t</span> r0;   <span class="comment">/**&lt; The r0 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r1;   <span class="comment">/**&lt; The r1 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r2;   <span class="comment">/**&lt; The r2 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r3;   <span class="comment">/**&lt; The r3 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r4;   <span class="comment">/**&lt; The r4 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r5;   <span class="comment">/**&lt; The r5 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r6;   <span class="comment">/**&lt; The r6 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r7;   <span class="comment">/**&lt; The r7 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r8;   <span class="comment">/**&lt; The r8 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r9;   <span class="comment">/**&lt; The r9 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r10;  <span class="comment">/**&lt; The r10 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r11;  <span class="comment">/**&lt; The r11 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r12;  <span class="comment">/**&lt; The r12 register. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> X64 <span class="comment">/* 64-bit */</span></span></span><br><span class="line">    <span class="keyword">reg_t</span> r13;  <span class="comment">/**&lt; The r13 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r14;  <span class="comment">/**&lt; The r14 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r15;  <span class="comment">/**&lt; The r15 register. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r16;  <span class="comment">/**&lt; The r16 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r17;  <span class="comment">/**&lt; The r17 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r18;  <span class="comment">/**&lt; The r18 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r19;  <span class="comment">/**&lt; The r19 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r20;  <span class="comment">/**&lt; The r20 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r21;  <span class="comment">/**&lt; The r21 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r22;  <span class="comment">/**&lt; The r22 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r23;  <span class="comment">/**&lt; The r23 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r24;  <span class="comment">/**&lt; The r24 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r25;  <span class="comment">/**&lt; The r25 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r26;  <span class="comment">/**&lt; The r26 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r27;  <span class="comment">/**&lt; The r27 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r28;  <span class="comment">/**&lt; The r28 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r29;  <span class="comment">/**&lt; The r29 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> r30; <span class="comment">/**&lt; The r30 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> lr;  <span class="comment">/**&lt; The link register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for r30/lr register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> r31; <span class="comment">/**&lt; The r31 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> sp;  <span class="comment">/**&lt; The stack pointer register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> xsp; <span class="comment">/**&lt; The platform-independent name for the stack pointer register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for r31/sp register. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The program counter.</span></span><br><span class="line"><span class="comment">     * \note This field is not always set or read by all API routines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    byte *pc;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        uint xflags; <span class="comment">/**&lt; The platform-independent name for condition flags. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            uint nzcv; <span class="comment">/**&lt; Condition flags (status register). */</span></span><br><span class="line">            uint fpcr; <span class="comment">/**&lt; Floating-Point Control Register. */</span></span><br><span class="line">            uint fpsr; <span class="comment">/**&lt; Floating-Point Status Register. */</span></span><br><span class="line">        &#125;; <span class="comment">/**&lt; AArch64 flag registers. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for flag registers. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span> <span class="comment">/* 32-bit */</span></span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> r13; <span class="comment">/**&lt; The r13 register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> sp;  <span class="comment">/**&lt; The stack pointer register.*/</span></span><br><span class="line">        <span class="keyword">reg_t</span> xsp; <span class="comment">/**&lt; The platform-independent name for the stack pointer register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for r13/sp register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> r14; <span class="comment">/**&lt; The r14 register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> lr;  <span class="comment">/**&lt; The link register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for r14/lr register. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The anonymous union of alternative names for r15/pc register.</span></span><br><span class="line"><span class="comment">     * \note This field is not always set or read by all API routines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> r15; <span class="comment">/**&lt; The r15 register. */</span></span><br><span class="line">        byte *pc;  <span class="comment">/**&lt; The program counter. */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        uint xflags; <span class="comment">/**&lt; The platform-independent name for full APSR register. */</span></span><br><span class="line">        uint apsr; <span class="comment">/**&lt; The application program status registers in AArch32. */</span></span><br><span class="line">        uint cpsr; <span class="comment">/**&lt; The current program status registers in AArch32. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for apsr/cpsr register. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span> <span class="comment">/* 64/32-bit */</span></span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The SIMD registers.  We would probably be ok if we did not preserve the</span></span><br><span class="line"><span class="comment">     * callee-saved registers (q4-q7 == d8-d15) but to be safe we preserve them</span></span><br><span class="line"><span class="comment">     * all.  We do not need anything more than word alignment for OP_vldm/OP_vstm,</span></span><br><span class="line"><span class="comment">     * and dr_simd_t has no fields larger than 32 bits, so we have no padding.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">dr_simd_t</span> simd[NUM_SIMD_SLOTS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* X86 */</span></span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xdi; <span class="comment">/**&lt; The platform-independent name for full rdi/edi register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rdi, edi); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rdi/edi register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rdi/edi register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xsi; <span class="comment">/**&lt; The platform-independent name for full rsi/esi register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rsi, esi); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rsi/esi register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rsi/esi register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xbp; <span class="comment">/**&lt; The platform-independent name for full rbp/ebp register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rbp, ebp); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rbp/ebp register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rbp/ebp register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xsp; <span class="comment">/**&lt; The platform-independent name for full rsp/esp register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rsp, esp); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rsp/esp register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rsp/esp register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xbx; <span class="comment">/**&lt; The platform-independent name for full rbx/ebx register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rbx, ebx); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rbx/ebx register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rbx/ebx register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xdx; <span class="comment">/**&lt; The platform-independent name for full rdx/edx register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rdx, edx); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rdx/edx register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rdx/edx register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xcx; <span class="comment">/**&lt; The platform-independent name for full rcx/ecx register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rcx, ecx); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rcx/ecx register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rcx/ecx register. */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xax; <span class="comment">/**&lt; The platform-independent name for full rax/eax register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rax, eax); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rax/eax register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rax/eax register. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> X64</span></span><br><span class="line">    <span class="keyword">reg_t</span> r8;  <span class="comment">/**&lt; The r8 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r9;  <span class="comment">/**&lt; The r9 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r10; <span class="comment">/**&lt; The r10 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r11; <span class="comment">/**&lt; The r11 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r12; <span class="comment">/**&lt; The r12 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r13; <span class="comment">/**&lt; The r13 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r14; <span class="comment">/**&lt; The r14 register. \note For 64-bit DR builds only. */</span></span><br><span class="line">    <span class="keyword">reg_t</span> r15; <span class="comment">/**&lt; The r15 register. \note For 64-bit DR builds only. */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">reg_t</span> xflags; <span class="comment">/**&lt; The platform-independent name for</span></span><br><span class="line"><span class="comment">                           full rflags/eflags register. */</span></span><br><span class="line">        <span class="keyword">reg_t</span> IF_X64_ELSE(rflags, eflags); <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                                rflags/eflags register. */</span></span><br><span class="line">    &#125;; <span class="comment">/**&lt; The anonymous union of alternative names for rflags/eflags register. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Anonymous union of alternative names for the program counter /</span></span><br><span class="line"><span class="comment">     * instruction pointer (eip/rip). \note This field is not always set or</span></span><br><span class="line"><span class="comment">     * read by all API routines.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        byte *xip; <span class="comment">/**&lt; The platform-independent name for full rip/eip register. */</span></span><br><span class="line">        byte *pc; <span class="comment">/**&lt; The platform-independent alt name for full rip/eip register. */</span></span><br><span class="line">        <span class="function">byte *<span class="title">IF_X64_ELSE</span><span class="params">(rip, eip)</span></span>; <span class="comment">/**&lt; The platform-dependent name for</span></span><br><span class="line"><span class="comment">                                          rip/eip register. */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    byte padding[PRE_XMM_PADDING]; <span class="comment">/**&lt; The padding to get ymm field 32-byte aligned. */</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The SSE registers xmm0-xmm5 (-xmm15 on Linux) are volatile</span></span><br><span class="line"><span class="comment">     * (caller-saved) for 64-bit and WOW64, and are actually zeroed out on</span></span><br><span class="line"><span class="comment">     * Windows system calls.  These fields are ignored for 32-bit processes</span></span><br><span class="line"><span class="comment">     * that are not WOW64, or if the underlying processor does not support</span></span><br><span class="line"><span class="comment">     * SSE.  Use dr_mcontext_xmm_fields_valid() to determine whether the</span></span><br><span class="line"><span class="comment">     * fields are valid.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When the fields are valid, on processors with AVX enabled (i.e.,</span></span><br><span class="line"><span class="comment">     * proc_has_feature(FEATURE_AVX) returns true), these fields will</span></span><br><span class="line"><span class="comment">     * contain the full ymm register values; otherwise, the top 128</span></span><br><span class="line"><span class="comment">     * bits of each slot will be undefined.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">dr_ymm_t</span> ymm[NUM_SIMD_SLOTS];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ARM/X86 */</span></span></span><br><span class="line">&#125; <span class="keyword">dr_mcontext_t</span>;</span><br></pre></td></tr></table></figure>
<p>接下来就是获取和设置fuzzed的目标函数参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//save or restore arguments</span></span><br><span class="line"><span class="keyword">if</span> (!options.no_loop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fuzz_target.iteration == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; options.num_fuz_args; i++)</span><br><span class="line">            options.func_args[i] = drwrap_get_arg(wrapcxt, i);	<span class="comment">//首次运行先获取运行参数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; options.num_fuz_args; i++)</span><br><span class="line">            drwrap_set_arg(wrapcxt, i, options.func_args[i]);	<span class="comment">//设置运行参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当目标函数退出后，执行<code>post_fuzz_handler</code>函数，会恢复栈顶指针和pc地址，以此实现目标函数的循环调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">post_fuzz_handler(<span class="keyword">void</span> *wrapcxt, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dr_mcontext_t</span> *mc;</span><br><span class="line">    mc = drwrap_get_mcontext(wrapcxt);	<span class="comment">//获取上下文信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!options.debug_mode) &#123;</span><br><span class="line">		WriteCommandToPipe(<span class="string">'K'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        debug_data.post_handler_called++;</span><br><span class="line">        dr_fprintf(winafl_data.<span class="built_in">log</span>, <span class="string">"In post_fuzz_handler\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We don't need to reload context in case of network-based fuzzing. */</span></span><br><span class="line">    <span class="keyword">if</span> (options.no_loop)</span><br><span class="line">        <span class="keyword">return</span>;	<span class="comment">//网络型Fuzzing无需重载上下文信息</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">//超过循环次数就退出进程</span></span><br><span class="line">    fuzz_target.iteration++;</span><br><span class="line">    <span class="keyword">if</span>(fuzz_target.iteration == options.fuzz_iterations) &#123;</span><br><span class="line">        dr_exit_process(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mc-&gt;xsp = fuzz_target.xsp;			<span class="comment">//恢复栈顶指针</span></span><br><span class="line">    mc-&gt;pc = fuzz_target.func_pc;		<span class="comment">//篡改pc地址加原目标函数地址</span></span><br><span class="line">	drwrap_redirect_execution(wrapcxt);	<span class="comment">//篡改执行流</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下整个<code>winafl</code>执行流程：</p>
<ol>
<li>afl-fuzz.exe通过创建命名管道与内存映射来实现与目标进程交互，其中管道用来发送和接收命令相互操作对方进程，内存映射主要用来记录覆盖率信息；</li>
<li>覆盖率记录主要通过<code>drmgr_register_bb_instrumentation_event</code>去设置BB执行的回调函数，通过<code>instrument_bb_coverage</code>或者<code>instrument_edge_coverage</code>来记录覆盖率情况，如果发现新的执行路径，就将样本放入队列目录中，用于后续文件变异，以提高代码覆盖率；</li>
<li>目标进程执行到目标函数后，会调用<code>pre_fuzz_handler</code>来存储上下文信息，包括寄存器和运行参数；</li>
<li>目标函数退出后，会调用<code>post_fuzz_handler</code>函数，记录恢复上下文信息，以执行回原目标函数，又回到第2步；</li>
<li>目录函数运行次数达到指定循环调用次数时，会中断进程退出。</li>
</ol>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2019/02/02/winafl中基于插桩的覆盖率反馈原理/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/winafl/">winafl</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 
<section id="comment">
  <h1 class="title">留言</h1>

  
</section>


 -->
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:riusksk.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/11/18/Fuzzing平台建设的研究与设计/">Fuzzing平台建设的研究与设计</a>
      </li>
    
      <li>
        <a href="/2019/11/02/Jandroid：半自动化Android应用逻辑漏洞挖掘/">Android应用逻辑漏洞半自动化挖掘思路</a>
      </li>
    
      <li>
        <a href="/2019/09/07/漫谈网络安全应急指导思想/">漫谈网络安全应急要略</a>
      </li>
    
      <li>
        <a href="/2019/08/18/安全研究的价值思考/">安全研究的价值思考</a>
      </li>
    
      <li>
        <a href="/2019/07/14/一些值得学习的Fuzzer开源项目/">一些值得学习的Fuzzer开源项目</a>
      </li>
    
      <li>
        <a href="/2019/06/29/Infiltrate2019议题学习/">Infiltrate2019议题学习</a>
      </li>
    
      <li>
        <a href="/2019/05/11/2019年哪些安全大会的议题值得学习/">2019年哪些安全大会的议题值得学习</a>
      </li>
    
      <li>
        <a href="/2019/05/03/读《一本小小的蓝色逻辑书》/">读《一本小小的蓝色逻辑书》：识别常见的逻辑漏洞</a>
      </li>
    
      <li>
        <a href="/2019/03/30/RSS-优秀的个人情报来源/">RSS: 优秀的个人情报来源</a>
      </li>
    
      <li>
        <a href="/2019/02/22/今年的OffensiveCon大会议题不错/">今年的OffensiveCon大会议题质量不错</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/技术分享/">技术分享</a><small>58</small></li>
  
    <li><a href="/categories/随笔杂谈/">随笔杂谈</a><small>26</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/0day/" style="font-size: 11.67px;">0day</a> <a href="/tags/ASLR/" style="font-size: 10px;">ASLR</a> <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Apple/" style="font-size: 10px;">Apple</a> <a href="/tags/BlackHat/" style="font-size: 13.33px;">BlackHat</a> <a href="/tags/Bochspwn/" style="font-size: 10px;">Bochspwn</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/CVE/" style="font-size: 10px;">CVE</a> <a href="/tags/CanSecWest/" style="font-size: 11.67px;">CanSecWest</a> <a href="/tags/DEP/" style="font-size: 10px;">DEP</a> <a href="/tags/EAT/" style="font-size: 10px;">EAT</a> <a href="/tags/EMET/" style="font-size: 10px;">EMET</a> <a href="/tags/Flash/" style="font-size: 15px;">Flash</a> <a href="/tags/Fuzzer/" style="font-size: 10px;">Fuzzer</a> <a href="/tags/Fuzzing/" style="font-size: 11.67px;">Fuzzing</a> <a href="/tags/GS/" style="font-size: 10px;">GS</a> <a href="/tags/Hacking-Team/" style="font-size: 18.33px;">Hacking Team</a> <a href="/tags/Heap-Spray/" style="font-size: 10px;">Heap Spray</a> <a href="/tags/Hook/" style="font-size: 10px;">Hook</a> <a href="/tags/MemProt/" style="font-size: 10px;">MemProt</a> <a href="/tags/OSX/" style="font-size: 13.33px;">OSX</a> <a href="/tags/PHDays/" style="font-size: 10px;">PHDays</a> <a href="/tags/Perl/" style="font-size: 11.67px;">Perl</a> <a href="/tags/SafeSEH/" style="font-size: 10px;">SafeSEH</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/UAF/" style="font-size: 10px;">UAF</a> <a href="/tags/UXSS/" style="font-size: 10px;">UXSS</a> <a href="/tags/Windows/" style="font-size: 11.67px;">Windows</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/bochspwn/" style="font-size: 10px;">bochspwn</a> <a href="/tags/fuzz/" style="font-size: 13.33px;">fuzz</a> <a href="/tags/fuzzing/" style="font-size: 11.67px;">fuzzing</a> <a href="/tags/honggfuzz/" style="font-size: 16.67px;">honggfuzz</a> <a href="/tags/iOS/" style="font-size: 11.67px;">iOS</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/rootkit/" style="font-size: 11.67px;">rootkit</a> <a href="/tags/shellcode/" style="font-size: 10px;">shellcode</a> <a href="/tags/v8/" style="font-size: 10px;">v8</a> <a href="/tags/winafl/" style="font-size: 10px;">winafl</a> <a href="/tags/书籍/" style="font-size: 20px;">书籍</a> <a href="/tags/信息安全/" style="font-size: 10px;">信息安全</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/威胁建模/" style="font-size: 10px;">威胁建模</a> <a href="/tags/学历/" style="font-size: 10px;">学历</a> <a href="/tags/安全大会/" style="font-size: 10px;">安全大会</a> <a href="/tags/安全审计/" style="font-size: 11.67px;">安全审计</a> <a href="/tags/安全研究/" style="font-size: 11.67px;">安全研究</a> <a href="/tags/思维导图/" style="font-size: 10px;">思维导图</a> <a href="/tags/恶意软件/" style="font-size: 11.67px;">恶意软件</a> <a href="/tags/打印机/" style="font-size: 10px;">打印机</a> <a href="/tags/攻防/" style="font-size: 10px;">攻防</a> <a href="/tags/溢出/" style="font-size: 10px;">溢出</a> <a href="/tags/漏洞/" style="font-size: 13.33px;">漏洞</a> <a href="/tags/漏洞挖掘/" style="font-size: 13.33px;">漏洞挖掘</a> <a href="/tags/监控取证/" style="font-size: 10px;">监控取证</a> <a href="/tags/程序员/" style="font-size: 10px;">程序员</a> <a href="/tags/编程/" style="font-size: 11.67px;">编程</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/职业/" style="font-size: 10px;">职业</a> <a href="/tags/虚拟机/" style="font-size: 10px;">虚拟机</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/逻辑/" style="font-size: 10px;">逻辑</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2019 riusksk
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  & Hosted by <a href="http://github.com" target="_blank">GitHub</a>
  <!--<span id="busuanzi_container_site_pv" >
    ，本站总访问量<span id="busuanzi_value_site_pv" ></span>次
  </span>
  -->
  </p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




<div id='bg'></div>
</body>
</html>