<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>第 2 页 | riusksk&#39;s blog</title>
  <meta name="author" content="riusksk" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="riusksk&#39;s blog" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="riusksk&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78773323-1', 'auto');
	ga('send', 'pageview');

</script>



  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">riusksk&#39;s blog</a></h1>
  <h2><a href="/">攀蟾折桂摄寰宇，摘星揽月御乾坤。踏云踩雾骋宵壤，驱风逐日闯天地。 ------泉哥</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/atom.xml">RSS订阅</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-30T11:06:31.000Z"><a href="/2018/12/30/推荐今年C3黑客大会上的几个议题/">2018-12-30</a></time>
      
      
  
    <h1 class="title"><a href="/2018/12/30/推荐今年C3黑客大会上的几个议题/">推荐今年C3黑客大会上的几个议题</a></h1>
  

    </header>
    <div class="entry">
      
        <p>最近几天在德国举办的 The 35th Chaos Communication Congress (35C3) 黑客大会，在Twitter上传得火热，在国内却无人问津。</p>
<p>从这可以看出同为微博的安全圈氛围是完全不同的，新浪微博还是偏娱乐些的，而且国外的圈子自然比天朝的要大得多，很多国家的人在上面交流。</p>
<p>所以，我现在经常混Twitter，当作获取安全资讯的途径，新浪微博就真的当作看新闻的了……</p>
<h3 id="德国C3混沌黑客大会"><a href="#德国C3混沌黑客大会" class="headerlink" title="德国C3混沌黑客大会"></a>德国C3混沌黑客大会</h3><p>Chaos Communication Congress（C3）大会是每年在德国举办的黑客大会，直译过来就是”混沌通信大会“，圈内通常叫”C3“，今年是第35届，所以叫35c3，今年还有CTF比赛，一些打过pwn2own的人出了一些浏览器实际漏洞的题目，也蛮具有实战价值的。</p>
<p>每年这大会都会以演讲视频的方式分享出各个议题，以前大多是聚焦在无线电安全，所以一些什么2G\3G\4G短信、电话窃听经常出自该会议。今年也有一些不错的软件安全相关的议题，下面推荐几个鄙人自认为不错的几个议题。</p>
<h3 id="From-Zero-to-Zero-Day"><a href="#From-Zero-to-Zero-Day" class="headerlink" title="From Zero to Zero Day"></a>From Zero to Zero Day</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyp0431o6oj30ju0hxtft.jpg" alt="image-20181230193447667"></p>
<p>大会上有个议题叫 “From Zero to Zero Day”，演讲者是位高中生，讲述他自己如何在一年之内，从无任何安全基础到挖掘到第一枚Edge浏览器远程执行代码漏洞的经历。</p>
<p>总结来讲就是：</p>
<p>1、学习编程语言（C/C++、asm等等）</p>
<p>2、学习操作系统原理</p>
<p>3、学习常见二进制漏洞原理</p>
<p>4、打打CTF，写写write-up</p>
<p>5、学习并实践去分析真实的漏洞案例，就是直接看代码，调代码</p>
<p>6、不断重复上述练习</p>
<p>我直接帖几张关键截图，也推荐大家去听听（视频链接：<a href="https://media.ccc.de/v/35c3-9657-from_zero_to_zero_day）：" target="_blank" rel="external">https://media.ccc.de/v/35c3-9657-from_zero_to_zero_day）：</a></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyozsxuptzj30hz0aatcu.jpg" alt="image-20181230192405638"></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyozt7f18tj30jf0avwjw.jpg" alt="image-20181230192425929"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fyozqdnwdwj30k30axgoz.jpg" alt="image-20181230192131880"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyozs2o8i2j30k70awtb3.jpg" alt="image-20181230192320182"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fyozrme322j30k50atadg.jpg" alt="image-20181230192254473"></p>
<h3 id="Attack-Chrome-IPC"><a href="#Attack-Chrome-IPC" class="headerlink" title="Attack Chrome IPC"></a>Attack Chrome IPC</h3><p><img src="/Users/riusksk/Library/Application Support/typora-user-images/image-20181230193950157.png" alt="image-20181230193950157"></p>
<p>这个议题之前作者在韩国PoC大会上讲过，并在网上公布过pdf（<a href="https://data.hackinn.com/ppt/2018韩国POC安全大会/ned.pdf），主要讲他之前在Hack2Win" target="_blank" rel="external">https://data.hackinn.com/ppt/2018韩国POC安全大会/ned.pdf），主要讲他之前在Hack2Win</a> bevx黑客大赛上用于黑掉Chrome浏览器的IPC漏洞，此次C3大会的演讲视频参见：<a href="https://media.ccc.de/v/35c3-9579-attacking_chrome_ipc" target="_blank" rel="external">https://media.ccc.de/v/35c3-9579-attacking_chrome_ipc</a></p>
<p>这议题里面讲了作者一些研究二进制漏洞的一些学习和研究的方法，比如做代码审计、打CTF，也介绍了他这几年的安全研究历程，比国内流行晒crash+CVE的方式更接地气。</p>
<p>最后介绍如何使用 libfuzzer+libprotobuf-mutator去fuzz chrome IPC，并开源fuzzer代码合并到chroium项目中。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyp0grvcxuj30wk0g3aej.jpg" alt="image-20181230194648886"></p>
<h3 id="Jailbreaking-iOS-From-past-to-present"><a href="#Jailbreaking-iOS-From-past-to-present" class="headerlink" title="Jailbreaking iOS From past to present"></a>Jailbreaking iOS From past to present</h3><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fyp4tb6ppej30lb0c04cb.jpg" alt="image-20181230202552499"></p>
<p>讲iOS越狱发展史的，可以学习到iOS上各种安全机制的原理以及绕过方法，画了不少原理图，通俗易懂不少。对于想了解整个iOS越狱技术发展历程的同学，这确实是份不错的资料。</p>
<p>作者这次也在推持上放出了pdf和视频：</p>
<p>pdf: <a href="https://api.tihmstar.net/35c3slides.pdf" target="_blank" rel="external">https://api.tihmstar.net/35c3slides.pdf</a></p>
<p>video: <a href="https://media.ccc.de/v/35c3-9618-jailbreaking_ios" target="_blank" rel="external">https://media.ccc.de/v/35c3-9618-jailbreaking_ios</a></p>
<p>整个议题主要围绕以下几点展开：</p>
<ul>
<li>越狱类型（非完美越狱、完美越狱……）</li>
<li>Exploit mitigations (ASLR, iBoot-level AES, KPP, KTRR, PAC) </li>
<li>Kernel patches (h3lix) </li>
<li>Kppless jailbreaks</li>
<li>越狱的未来趋势</li>
</ul>
<h1 id="The-Layman’s-Guide-to-Zero-Day-Engineering"><a href="#The-Layman’s-Guide-to-Zero-Day-Engineering" class="headerlink" title="The Layman’s Guide to Zero-Day Engineering"></a>The Layman’s Guide to Zero-Day Engineering</h1><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyp2wxxr28j30yw0ihgr0.jpg" alt="image-20181230211151217"></p>
<p>Ret2公司分享如何寻找webkit攻击面并fuzz的方法，是基于MozillaSecurity的dharma语法生成框架写的js fuzzer，以及如何借助IDA+<a href="https://github.com/gaasedelen/lighthouse" target="_blank" rel="external">Lighthouse</a>开源插件（正是Ret2团队开发的，曾获得过IDA插件比赛的二等奖）来分析代码覆盖率问题。</p>
<p>除此之外，也介绍如何利用frida去hook mach_msg，用来fuzz WindowServer，最后用WindowServer的漏洞来实现root提权。</p>
<p>他们在其博客（<a href="https://blog.ret2.io）上也分享过不少漏洞研究方面的干货，这次分享的内容也大部分就是来自博客上的一些文章。" target="_blank" rel="external">https://blog.ret2.io）上也分享过不少漏洞研究方面的干货，这次分享的内容也大部分就是来自博客上的一些文章。</a></p>
<p>里面还提到长亭的real world ctf比赛了。</p>
<p>这里有张比较有意思的图，发出来给大伙看下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fyp3j3xqdgj30z00jn4qp.jpg" alt="image-20181230213304029"></p>
<p>视频链接：<a href="https://media.ccc.de/v/35c3-9979-the_layman_s_guide_to_zero-day_engineering" target="_blank" rel="external">https://media.ccc.de/v/35c3-9979-the_layman_s_guide_to_zero-day_engineering</a></p>
<h3 id="Modern-Windows-Userspace-Exploitation"><a href="#Modern-Windows-Userspace-Exploitation" class="headerlink" title="Modern Windows Userspace Exploitation"></a>Modern Windows Userspace Exploitation</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fyp3yvr0eaj30tl0i815k.jpg" alt="image-20181230214817405"></p>
<p>视频链接：<a href="https://media.ccc.de/v/35c3-9660-modern_windows_userspace_exploitation" target="_blank" rel="external">https://media.ccc.de/v/35c3-9660-modern_windows_userspace_exploitation</a></p>
<p>微软MSRC的人过来分享下windows平台下的一些二进制漏洞利用方法，包括ROP绕过DEP、信息泄露绕过ASLR、绕过CFG、ACG、CIG等等，并现场给了一些演示，不过看起来像是一些CTF赛题，演示的相关代码已放在作者的github上：<a href="https://github.com/saaramar" target="_blank" rel="external">https://github.com/saaramar</a></p>
<p>都是一些利用系统漏洞防御技术的原理与绕过技术的总结，连各种漏洞缓解机制绕过的微软奖励都给大家标注上了，其实有点类似上面Jailbreaking iOS议题的Windows版本。</p>
<p>最后来张Exploit Mitigations清单：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fyp4b42qn5j30rs0hvdir.jpg" alt="image-20181230215938958"></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>后面官方可能还会继续更新演讲视频，可以关注官方twitter（@c3voc_releases）获取消息。</p>
<p>另外，对于英语不好的同学，不妨下个”腾讯翻译“同声翻译试下，虽然中文翻译没那么准确，但看看显示的英文单词也能知道个大意：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fyp0n9b99lj31400u0b29.jpg" alt="image-20181230195201468"></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/12/30/推荐今年C3黑客大会上的几个议题/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-28T12:17:12.000Z"><a href="/2018/12/28/2018年读过的书/">2018-12-28</a></time>
      
      
  
    <h1 class="title"><a href="/2018/12/28/2018年读过的书/">2018年读过的书</a></h1>
  

    </header>
    <div class="entry">
      
        <p>从2018年开始一直坚持每月读2本书以上，庆幸自己坚持下来了，共读了38本书，也希望明年能够继续坚持。</p>
<p>有些是实体书，有些是在微信读书上看的电子版，在手机app上看书确实会高效很多，今年有一半的书是在微信读书上看的，非常适合空闲时间阅读，以及像坐地铁、等地铁这种零碎的时间。</p>
<p>下面是我今年读过的书单，分别都打个分数，8分及以上的代表推荐，6分以下的别看：</p>
<ol>
<li>《人性的弱点》（6分）</li>
<li>《代码整洁之道》（8分）</li>
<li>《如何阅读一本书》（8分）</li>
<li>《两晋南北朝那些事》（7分）</li>
<li>《软技能：代码之外的生存指南》（8分）</li>
<li>《秋叶：如何高效读懂一本书》（6分）</li>
<li>《横向领导力》（7分）</li>
<li>《程序员成长课》（8分）</li>
<li>《英语写作手册》（8分）</li>
<li>《爆款文案》（7分）</li>
<li>《运营之光》（8分）</li>
<li>《威胁建模》（7分）</li>
<li>《程序员的英语》（7分）</li>
<li>《冰鉴全鉴》（2分）</li>
<li>《内向者沟通圣经》（4分）</li>
<li>《灰度决策》（4分）</li>
<li>《启功行书技法》（8分）</li>
<li>《见识》（9分）</li>
<li>《半小时漫画中国史1、2》（7分）</li>
<li>《Web安全之机器学习入门》（6分）</li>
<li>《秦崩》（8分）</li>
<li>《启功给你讲书法》（8分）</li>
<li>《思考，快与慢》（10分）</li>
<li>《三国志》（8分）</li>
<li>《季羡林谈写作》（6分）</li>
<li>《Android应用安全防护与逆向分析》（7分）</li>
<li>《精进：如何成为一个很厉害的人》（8分）</li>
<li>《非暴力沟通》（9分）</li>
<li>《系统架构设计》（7分）</li>
<li>《人人都是产品经理》（8分）</li>
<li>《漏洞》（7分）</li>
<li>《风格感觉：21世纪写作指南》（8分）</li>
<li>《态度》（8分）</li>
<li>《高效阅读》（5分）</li>
<li>《写给大家看的设计书》（10分）</li>
<li>《硅谷钢铁侠：埃隆·马斯克的冒险人生》（8分）</li>
<li>《八卦医学史2》（6分）</li>
<li>《从0到1：开启商业与未来的秘密》（7分）</li>
</ol>
<p> 所以8分以上的推荐书籍有：</p>
<p><strong>《代码整洁之道》（8分）</strong></p>
<p><strong>《如何阅读一本书》（8分）</strong></p>
<p><strong>《软技能：代码之外的生存指南》（8分）</strong></p>
<p><strong>《程序员成长课》（8分）</strong></p>
<p><strong>《英语写作手册》（8分）</strong></p>
<p><strong>《运营之光》（8分）</strong></p>
<p><strong>《启功行书技法》（8分）</strong></p>
<p><strong>《见识》（9分）</strong></p>
<p><strong>《秦崩》（8分）</strong></p>
<p><strong>《启功给你讲书法》（8分）</strong></p>
<p><strong>《思考，快与慢》（10分）</strong></p>
<p><strong>《三国志》（8分）</strong></p>
<p><strong>《精进：如何成为一个很厉害的人》（8分）</strong></p>
<p><strong>《非暴力沟通》（9分）</strong></p>
<p><strong>《人人都是产品经理》（8分）</strong></p>
<p><strong>《风格感觉：21世纪写作指南》（8分）</strong></p>
<p><strong>《态度》（8分）</strong></p>
<p><strong>《写给大家看的设计书》（10分）</strong></p>
<p><strong>《硅谷钢铁侠：埃隆·马斯克的冒险人生》（8分）</strong></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/12/28/2018年读过的书/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/随笔杂谈/">随笔杂谈</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/书籍/">书籍</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-22T00:13:28.000Z"><a href="/2018/12/22/bochspwn-reloaded/">2018-12-22</a></time>
      
      
  
    <h1 class="title"><a href="/2018/12/22/bochspwn-reloaded/">Bochspwn漏洞挖掘技术深究(2)：内核未初始化漏洞检测</a></h1>
  

    </header>
    <div class="entry">
      
        <p>本文主要介绍<a href="https://github.com/googleprojectzero/bochspwn-reloaded" target="_blank" rel="external">Bochspwn Reloaded</a>内核未初始化漏洞检测技术，它采用污点追踪对内核层向用户层泄露数据的行为进行检测。</p>
<p>关于bochs插桩技术参考<a href="http://riusksk.me/2018/12/01/bochspwn1/" target="_blank" rel="external">《Bochspwn漏洞挖掘技术深究(1)：Double Fetches 检测》</a>，此处不再赘述。</p>
<p>直接先看下instrument.h中实现插桩函数有哪些：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bochs初始化CPU对象时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_initialize</span><span class="params">(<span class="keyword">unsigned</span> cpu)</span></span>;	</span><br><span class="line"><span class="comment">// Bochs析构CPU对象时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_exit</span><span class="params">(<span class="keyword">unsigned</span> cpu)</span></span>;</span><br><span class="line"><span class="comment">//Bochs每次执行中断操作（软件中断、硬件中断或异常）时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_interrupt</span><span class="params">(<span class="keyword">unsigned</span> cpu, <span class="keyword">unsigned</span> <span class="built_in">vector</span>)</span></span>;</span><br><span class="line"><span class="comment">// Bochs执行指令前的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_before_execution</span><span class="params">(<span class="keyword">unsigned</span> cpu, bxInstruction_c *i)</span></span>;</span><br><span class="line"><span class="comment">// Bochs执行指令后的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_after_execution</span><span class="params">(<span class="keyword">unsigned</span> cpu, bxInstruction_c *i)</span></span>;</span><br><span class="line"><span class="comment">// Bochs访问线性内存时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_lin_access</span><span class="params">(<span class="keyword">unsigned</span> cpu, bx_address lin, bx_address phy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> len, <span class="keyword">unsigned</span> memtype, <span class="keyword">unsigned</span> rw)</span></span>;</span><br><span class="line"><span class="comment">// WRMSR指令（写模式定义寄存器）被执行时的回调函数，MSR寄存器数与值作为参数传递给回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_wrmsr</span><span class="params">(<span class="keyword">unsigned</span> cpu, <span class="keyword">unsigned</span> addr, Bit64u value)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="初始化工作"><a href="#初始化工作" class="headerlink" title="初始化工作"></a>初始化工作</h3><p>第一篇中讲过<code>bx_instr_initialize</code>主要用来加载配置信息，针对不同的系统环境设置不同的数据结构偏移地址，用来提供需要的进程/线程等重要信息。在这里它另外增加污点追踪功能的初始化工作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the taint subsystem.</span></span><br><span class="line">taint::initialize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize helper taint allocations.</span></span><br><span class="line">globals::pool_taint_alloc = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(kTaintHelperAllocSize);</span><br><span class="line"><span class="built_in">memset</span>(globals::pool_taint_alloc, kPoolTaintByte, kTaintHelperAllocSize);</span><br><span class="line"></span><br><span class="line">globals::stack_taint_alloc = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(kTaintHelperAllocSize);</span><br><span class="line"><span class="built_in">memset</span>(globals::stack_taint_alloc, kStackTaintByte, kTaintHelperAllocSize);</span><br></pre></td></tr></table></figure>
<p>主要作一些用于污点信息记录的内存结构分配与VEH异常处理回调设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve a memory region for the taint data.</span></span><br><span class="line">  taint_area = (<span class="keyword">uint8_t</span> *)VirtualAlloc(<span class="literal">NULL</span>, kTaintAreaSize, MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register a VEH handler to commit taint memory touched in other taint</span></span><br><span class="line">  <span class="comment">// functions.</span></span><br><span class="line">  AddVectoredExceptionHandler(<span class="comment">/*FirstHandler=*/</span><span class="number">1</span>, OvercommitHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VEH回调函数实现如下，当发生访问违例时，若异常地址不在污点内存区域，则将其设置为可读写内存，然后继续执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> LONG CALLBACK <span class="title">OvercommitHandler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PEXCEPTION_POINTERS ExceptionInfo</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *excp_address = (<span class="keyword">uint8_t</span> *)ExceptionInfo-&gt;ExceptionRecord-&gt;ExceptionInformation[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (excp_address &gt;= taint_area &amp;&amp; excp_address &lt; &amp;taint_area[kTaintAreaSize]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (VirtualAlloc((<span class="keyword">void</span> *)((<span class="keyword">uint64_t</span>)excp_address &amp; (~<span class="number">0xffff</span>)), <span class="number">0x10000</span>, MEM_COMMIT, PAGE_READWRITE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EXCEPTION_CONTINUE_EXECUTION;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断响应"><a href="#中断响应" class="headerlink" title="中断响应"></a>中断响应</h3><p>再看下<code>bx_instr_interrupt</code>函数实现，主要是发生中断时，检测该中断地址是否可写，并设置全局标志：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_interrupt</span><span class="params">(<span class="keyword">unsigned</span> cpu, <span class="keyword">unsigned</span> <span class="built_in">vector</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (globals::bp_active &amp;&amp; <span class="built_in">vector</span> == <span class="number">3</span>) &#123;</span><br><span class="line">    BX_CPU_C *pcpu = BX_CPU(cpu);</span><br><span class="line">    write_lin_mem(pcpu, globals::bp_address, <span class="number">1</span>, &amp;globals::bp_orig_byte);</span><br><span class="line"></span><br><span class="line">    globals::bp_active = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="污点标记与追踪"><a href="#污点标记与追踪" class="headerlink" title="污点标记与追踪"></a>污点标记与追踪</h3><p>bochspwn-reloaded会对内核分配的stack/heap/pools作污点标记：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fyf9luidhdj30jy09m75c.jpg" alt="image-20181222092741926"></p>
<p><strong>1、栈污点标记</strong></p>
<p>检测修改ESP寄存器的指令，比如：<code>ADD ESP, ...</code> <code>SUB ESP, ...</code> <code>AND ESP, …</code>，若在执行后（<code>bx_instr_after_execution</code>）ESP发生递减，则调用<code>taint::set_taint(new_rsp, length, /*tainted=*/true)</code>标记为污点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_before_execution</span><span class="params">(<span class="keyword">unsigned</span> cpu, bxInstruction_c *i)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> opcode = i-&gt;getIaOpcode();</span><br><span class="line">  <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">    <span class="keyword">case</span> BX_IA_SUB_EqId:</span><br><span class="line">    <span class="keyword">case</span> BX_IA_SUB_GqEq: <span class="comment">/* Stack allocation handling */</span> </span><br><span class="line">          ...</span><br><span class="line">	<span class="keyword">case</span> BX_IA_PUSH_Eq: <span class="comment">/* Allocator prologue handling. */</span> </span><br><span class="line">          ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_after_execution</span><span class="params">(<span class="keyword">unsigned</span> cpu, bxInstruction_c *i)</span> </span>&#123;</span><br><span class="line">  globals::rep_movs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (globals::rsp_change) &#123;</span><br><span class="line">    BX_CPU_C *pcpu = BX_CPU(cpu);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> new_rsp = pcpu-&gt;gen_reg[BX_64BIT_REG_RSP].rrx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (new_rsp &lt; globals::rsp_value) &#123;</span><br><span class="line">      <span class="keyword">uint64_t</span> length = globals::rsp_value - new_rsp;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (length &lt;= kTaintHelperAllocSize) &#123;</span><br><span class="line">        taint::set_taint(new_rsp, length, <span class="comment">/*tainted=*/</span><span class="literal">true</span>);</span><br><span class="line">        write_lin_mem(pcpu, new_rsp, length, (<span class="keyword">void</span> *)globals::stack_taint_alloc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (globals::config.track_origins) &#123;</span><br><span class="line">          taint::set_origin(new_rsp, length, pcpu-&gt;prev_rip);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    globals::rsp_change = <span class="literal">false</span>;</span><br><span class="line">    globals::rsp_value = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、堆/Pools污点标记</strong></p>
<p>检测内核内存分配操作的指令，则调用<code>taint::set_taint(address, size, /*tainted=*/true)</code>进行污点标记，主要通过<code>bx_instr_wrmsr</code>函数来实现，当写入的地址是<code>MSR_LSTAR</code>寄存器时，它代表着syscall调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSR_LSTAR	0xc0000082 <span class="comment">/* long mode SYSCALL target */</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_wrmsr</span><span class="params">(<span class="keyword">unsigned</span> cpu, <span class="keyword">unsigned</span> addr, Bit64u value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (addr == MSR_LSTAR) &#123;</span><br><span class="line">    globals::nt_base = value - globals::config.KiSystemCall64_offset; <span class="comment">// ntoskrnl.exe中nt!KiSystemCall64偏移地址，用于获取内核基址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; globals::config.pool_alloc_prologues.size(); i++) &#123;</span><br><span class="line">      globals::config.pool_alloc_prologues[i] += globals::nt_base;</span><br><span class="line">    &#125;</span><br><span class="line">    set_breakpoints_bulk(globals::config.pool_alloc_prologues, BP_POOL_ALLOC_PROLOGUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; globals::config.pool_alloc_epilogues.size(); i++) &#123;</span><br><span class="line">      globals::config.pool_alloc_epilogues[i] += globals::nt_base;</span><br><span class="line">    &#125;</span><br><span class="line">    set_breakpoints_bulk(globals::config.pool_alloc_epilogues, BP_POOL_ALLOC_EPILOGUE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>pool_alloc_prologues</code>与<code>pool_alloc_epilogues</code>分别代表alloc函数的前序与后序函数，以下是windows-x64系统配置下的地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pool_alloc_prologues  = 0x1E0590</span><br><span class="line">pool_alloc_epilogues  = 0x1E07AD</span><br></pre></td></tr></table></figure>
<p><strong>3、污点清除</strong><br>当栈顶弹出或者堆块调用free函数前序指令（Linux下配置地址），以及内存拷贝的目标地址是内核地址时，均将其污点标记清除，如果是win平台则主要依靠<code>bx_instr_lin_access</code>来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_lin_access</span><span class="params">(<span class="keyword">unsigned</span> cpu, bx_address lin, bx_address phy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> len, <span class="keyword">unsigned</span> memtype, <span class="keyword">unsigned</span> rw)</span> </span>&#123;</span><br><span class="line">  BX_CPU_C *pcpu = BX_CPU(cpu);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> pc = pcpu-&gt;prev_rip;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (rw != BX_WRITE &amp;&amp; rw != BX_RW) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pcpu-&gt;long_mode() || !windows::check_kernel_addr(pc) || !windows::check_kernel_addr(lin)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (globals::rep_movs) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> rsp = pcpu-&gt;gen_reg[BX_64BIT_REG_RSP].rrx;</span><br><span class="line">  <span class="keyword">if</span> (globals::rsp_locked.find(rsp) != globals::rsp_locked.end()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  taint::set_taint(lin, len, <span class="comment">/*tainted=*/</span><span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、污点传播</strong><br>在<code>bx_instr_before_execution</code>中主要对以下操作指令作检测，指令形式主要为 <code>&lt;REP&gt; MOVS{B,D}</code>，用于污点传播追踪：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> opcode = i-&gt;getIaOpcode();</span><br><span class="line">  <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">    <span class="keyword">case</span> BX_IA_MOV_GqEq: <span class="comment">/* Standard library memcpy() prologue handling. */</span> </span><br><span class="line">          ...</span><br><span class="line">    <span class="keyword">case</span> BX_IA_REP_MOVSB_YbXb:</span><br><span class="line">    <span class="keyword">case</span> BX_IA_REP_MOVSW_YwXw:</span><br><span class="line">    <span class="keyword">case</span> BX_IA_REP_MOVSD_YdXd:</span><br><span class="line">    <span class="keyword">case</span> BX_IA_REP_MOVSQ_YqXq: <span class="comment">/* Inline memcpy handling */</span> </span><br><span class="line">          ...</span><br><span class="line">        <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        	<span class="keyword">case</span> BX_IA_REP_MOVSB_YbXb: mult = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">case</span> BX_IA_REP_MOVSW_YwXw: mult = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">case</span> BX_IA_REP_MOVSD_YdXd: mult = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">case</span> BX_IA_REP_MOVSQ_YqXq: mult = <span class="number">8</span>; <span class="keyword">break</span>;</span><br><span class="line">      	&#125;</span><br><span class="line">        ...</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">case</span> BX_IA_RET_Op64: <span class="comment">/* Allocator and memcpy() epilogue handling. */</span> </span><br><span class="line">          ...</span><br></pre></td></tr></table></figure>
<p>对于非<code>&lt;REP&gt; MOVS{B,D}</code>指令的内存访问：</p>
<ul>
<li>写操作：清除内存污点标记，标记为已初始化；</li>
<li>读操作：检测污点标记，如果shadow memory中标记为未初始化读取，则在guest memory中验证：标记不匹配则清除污点，否则若真为未初始化读取就当漏洞报告出来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* src_in_kernel */</span> &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> tainted_offset = <span class="number">0</span>;</span><br><span class="line">    taint::access_type type = taint::check_taint(pcpu, src, size, &amp;tainted_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == taint::METADATA_MARKER_MISMATCH) &#123;</span><br><span class="line">      taint::set_taint(src, size, <span class="comment">/*tainted=*/</span><span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == taint::ACCESS_INVALID) &#123;</span><br><span class="line">      process_bug_candidate(</span><br><span class="line">          pcpu, i, pcpu-&gt;prev_rip, src, size, dst, taint::get_origin(src + tainted_offset));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>总结起来，是否为漏洞主要基于以下几点：</p>
<p>1、<code>&lt;REP&gt; MOVS{B,D}</code>中 源地址为内核，目标地址为用户地址，从内核输出数据到用户</p>
<p>2、源地址被标记为污点</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/12/22/bochspwn-reloaded/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/Bochspwn/">Bochspwn</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-12-01T03:08:09.000Z"><a href="/2018/12/01/bochspwn1/">2018-12-01</a></time>
      
      
  
    <h1 class="title"><a href="/2018/12/01/bochspwn1/">Bochspwn漏洞挖掘技术深究(1)：Double Fetches 检测</a></h1>
  

    </header>
    <div class="entry">
      
        <p>虽然现在技术文章很少人看，大家都喜欢聊安全八卦，但技术文章输出是一种很好的学习方式。更重要的是，专业的文章是给专业的人看的，并非为了取悦所有人。</p>
<p>对于应用程序的代码插桩，有现成的Pin和DynamoRIO插桩框架，在Fuzzing中可以用来实现代码覆盖率的反馈驱动，这已经被应用到winafl，效果很好。除了挖洞，在逆向工程领域应用也很广泛。</p>
<p>上面都是针对应用层的，内核层的，上面的Pin和DynamoRIO就派不上用场了，对于这种系统内核级的指令插桩，有时就会采用虚拟化技术为实现，比如通过Qemu或Bochs虚拟机。</p>
<p>ProjectZero的j00ru大神就用bochs的插桩API为实现针对内核double fetches的监测，项目称为bochspwn，后来又采用污点追踪方式检测未初始化漏洞导致的内核信息泄露，叫bochspwn-reloaded。</p>
<p>Bochs Instrument API 文档参考：<a href="http://bochs.sourceforge.net/cgi-bin/lxr/source/instrument/instrumentation.txt" target="_blank" rel="external">http://bochs.sourceforge.net/cgi-bin/lxr/source/instrument/instrumentation.txt</a> ，在编译bochs时指定插桩代码目录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure [...] --enable-instrumentation=&quot;instrument/myinstrument&quot;</span><br></pre></td></tr></table></figure>
<p>下面是bochspwn中用到的API：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bochs初始化CPU对象时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_initialize</span><span class="params">(<span class="keyword">unsigned</span> cpu)</span></span>;	</span><br><span class="line"><span class="comment">// Bochs析构CPU对象时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_exit</span><span class="params">(<span class="keyword">unsigned</span> cpu)</span></span>;	</span><br><span class="line"><span class="comment">// Bochs访问线性内存时的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_lin_access</span><span class="params">(<span class="keyword">unsigned</span> cpu, bx_address lin, bx_address phy,<span class="keyword">unsigned</span> len, <span class="keyword">unsigned</span> memtype, <span class="keyword">unsigned</span> rw)</span></span>;	</span><br><span class="line"><span class="comment">// Bochs执行指令前的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_before_execution</span><span class="params">(<span class="keyword">unsigned</span> cpu, bxInstruction_c *i)</span></span>;</span><br></pre></td></tr></table></figure>
<p>bx_instr_initialize用来加载配置信息，针对不同的系统环境设置不同的数据结构偏移地址，用来提供需要的进程/线程等重要信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[general]</span><br><span class="line">trace_log_path      = memlog.bin</span><br><span class="line">modules_list_path   = modules.bin</span><br><span class="line"></span><br><span class="line">os                  = windows</span><br><span class="line">bitness             = 32</span><br><span class="line">version             = win10_32</span><br><span class="line"></span><br><span class="line">min_read_size       = 1</span><br><span class="line">max_read_size       = 16</span><br><span class="line">min_write_size      = 1</span><br><span class="line">max_write_size      = 16</span><br><span class="line"></span><br><span class="line">callstack_length    = 48</span><br><span class="line">write_as_text       = 0</span><br><span class="line"></span><br><span class="line">symbolize           = 0</span><br><span class="line">symbol_path         = &lt;symbols path&gt;</span><br><span class="line"></span><br><span class="line">[win7_32]</span><br><span class="line">kprcb               = 0x120</span><br><span class="line">current_thread      = 0x04</span><br><span class="line">tcb                 = 0x0</span><br><span class="line">process             = 0x150</span><br><span class="line">client_id           = 0x22c</span><br><span class="line">process_id          = 0</span><br><span class="line">thread_id           = 4</span><br><span class="line">create_time         = 0x200</span><br><span class="line">image_filename      = 0x16c</span><br><span class="line">kdversionblock      = 0x34</span><br><span class="line">psloadedmodulelist  = 0x18</span><br><span class="line">loadorder_flink     = 0x0</span><br><span class="line">basedllname         = 0x2c</span><br><span class="line">baseaddress         = 0x18</span><br><span class="line">sizeofimage         = 0x20</span><br><span class="line">us_len              = 0x0</span><br><span class="line">us_buffer           = 0x4</span><br><span class="line">teb_cid             = 0x20</span><br><span class="line">irql                = 0x24</span><br><span class="line">previous_mode       = 0x13a</span><br><span class="line">exception_list      = 0x0</span><br><span class="line">next_exception      = 0x0</span><br><span class="line">try_level           = 0xc</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>Bochspwn的核心功能实现就在于<code>bx_instr_lin_access</code>与<code>bx_instr_before_execution</code>两个函数。先看下<code>bx_instr_before_execution</code>的实现逻辑：</p>
<ol>
<li>忽略实模式real mode</li>
<li>忽略无关的系统调用中断指令，仅允许<code>int 0x2e</code>与 <code>int 0x80</code></li>
<li>获取当前进程/线程ID相关的信息，当发现漏洞时方便重现</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_before_execution</span><span class="params">(<span class="keyword">unsigned</span> cpu, bxInstruction_c *i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> client_id thread;</span><br><span class="line">  BX_CPU_C *pcpu = BX_CPU(cpu);</span><br><span class="line">  <span class="keyword">unsigned</span> opcode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We're not interested in instructions executed in real mode.</span></span><br><span class="line">  <span class="keyword">if</span> (!pcpu-&gt;protected_mode() &amp;&amp; !pcpu-&gt;long64_mode()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the system needs an additional invokement from here, call it now.</span></span><br><span class="line">  <span class="keyword">if</span> (globals::has_instr_before_execution_handler) &#123;</span><br><span class="line">    invoke_system_handler(BX_OS_EVENT_INSTR_BEFORE_EXECUTION, pcpu, i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Any system-call invoking instruction is interesting - this</span></span><br><span class="line">  <span class="comment">// is mostly due to 64-bit Linux which allows various ways</span></span><br><span class="line">  <span class="comment">// to be used for system-call invocation.</span></span><br><span class="line">  <span class="comment">// Note: We're not checking for int1, int3 nor into instructions.</span></span><br><span class="line">  opcode = i-&gt;getIaOpcode();</span><br><span class="line">  <span class="keyword">if</span> (opcode != BX_IA_SYSCALL &amp;&amp; opcode != BX_IA_SYSENTER &amp;&amp; opcode != BX_IA_INT_Ib) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The only two allowed interrupts are int 0x2e and int 0x80, which are legacy</span></span><br><span class="line">  <span class="comment">// ways to invoke system calls on Windows and linux, respectively.</span></span><br><span class="line">  <span class="keyword">if</span> (opcode == BX_IA_INT_Ib &amp;&amp; i-&gt;Ib() != <span class="number">0x2e</span> &amp;&amp; i-&gt;Ib() != <span class="number">0x80</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Obtain information about the current process/thread IDs.</span></span><br><span class="line">  <span class="keyword">if</span> (!invoke_system_handler(BX_OS_EVENT_FILL_CID, pcpu, &amp;thread)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process information about a new syscall depending on the current mode.</span></span><br><span class="line">  <span class="keyword">if</span> (!events::event_new_syscall(pcpu, &amp;thread)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看下<code>bx_instr_lin_access</code>实现逻辑：</p>
<ol>
<li>忽略仅读写指令</li>
<li>检测CPU类型（32位或64位）</li>
<li>判断当前指令地址pc是否为内核地址，判断访问的线性内存地址是否为用户层地址</li>
<li>检测读取的内存长度是否处于0~16字节之间，长度大小范围在config.txt中配置，仅处理此范围内的指令操作</li>
<li>通过上述条件之后，就代表可能存在内核漏洞，然后反汇编指令，然后填充日志记录信息</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bx_instr_lin_access</span><span class="params">(<span class="keyword">unsigned</span> cpu, bx_address lin, bx_address phy,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> len, <span class="keyword">unsigned</span> memtype, <span class="keyword">unsigned</span> rw)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  BX_CPU_C *pcpu = BX_CPU(cpu);</span><br><span class="line">  <span class="comment">// Not going to use physical memory address.</span></span><br><span class="line">  (<span class="keyword">void</span>)phy;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read-write instructions are currently not interesting.</span></span><br><span class="line">  <span class="keyword">if</span> (rw == BX_RW)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is the CPU in protected or long mode?</span></span><br><span class="line">  <span class="keyword">unsigned</span> mode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Note: DO NOT change order of these ifs. long64_mode must be called</span></span><br><span class="line">  <span class="comment">// before protected_mode, since it will also return "true" on protected_mode</span></span><br><span class="line">  <span class="comment">// query (well, long mode is technically protected mode).</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pcpu-&gt;long64_mode()) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> BX_SUPPORT_X86_64</span></span><br><span class="line">    mode = <span class="number">64</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// BX_SUPPORT_X86_64</span></span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pcpu-&gt;protected_mode()) &#123;</span><br><span class="line">    <span class="comment">// This is either protected 32-bit mode or 32-bit compat. long mode.</span></span><br><span class="line">    mode = <span class="number">32</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Nothing interesting.</span></span><br><span class="line">    <span class="comment">// TODO(gynvael): Well actually there is the smm_mode(), which</span></span><br><span class="line">    <span class="comment">// might be a little interesting, even if it's just the bochs BIOS</span></span><br><span class="line">    <span class="comment">// SMM code.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Is pc in kernel memory area?</span></span><br><span class="line">  <span class="comment">// Is lin in user memory area?</span></span><br><span class="line">  bx_address pc = pcpu-&gt;prev_rip;</span><br><span class="line">  <span class="keyword">if</span> (!invoke_system_handler(BX_OS_EVENT_CHECK_KERNEL_ADDR, &amp;pc, <span class="literal">NULL</span>) ||</span><br><span class="line">      !invoke_system_handler(BX_OS_EVENT_CHECK_USER_ADDR, &amp;lin, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">/* pc not in ring-0 or lin not in ring-3 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the access meets specified operand length criteria.</span></span><br><span class="line">  <span class="keyword">if</span> (rw == BX_READ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; globals::config.min_read_size || len &gt; globals::config.max_read_size) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt; globals::config.min_write_size || len &gt; globals::config.max_write_size) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save basic information about the access.</span></span><br><span class="line">  log_data_st::mem_access_type access_type;</span><br><span class="line">  <span class="keyword">switch</span> (rw) &#123;</span><br><span class="line">    <span class="keyword">case</span> BX_READ:</span><br><span class="line">      access_type = log_data_st::MEM_READ;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BX_WRITE:</span><br><span class="line">      access_type = log_data_st::MEM_WRITE;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BX_EXECUTE:</span><br><span class="line">      access_type = log_data_st::MEM_EXEC;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BX_RW:</span><br><span class="line">      access_type = log_data_st::MEM_RW;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Disassemble current instruction.</span></span><br><span class="line">  <span class="keyword">static</span> Bit8u ibuf[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> pc_disasm[<span class="number">64</span>];</span><br><span class="line">  <span class="keyword">if</span> (read_lin_mem(pcpu, pc, <span class="keyword">sizeof</span>(ibuf), ibuf)) &#123;</span><br><span class="line">    disassembler bx_disassemble;</span><br><span class="line">    bx_disassemble.disasm(mode == <span class="number">32</span>, mode == <span class="number">64</span>, <span class="number">0</span>, pc, ibuf, pc_disasm);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// With basic information filled in, process the access further.</span></span><br><span class="line">  process_mem_access(pcpu, lin, len, pc, access_type, pc_disasm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信息记录方式都是通过invoke_system_handler函数去处理自定义系统事件，目前主要支持4种操作系统（windows\linux\freebsd\openbsd），macOS还没搞过，原作者是说想继续实现macOS，这个值得尝试开发下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag_kSystemEventHandlers</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *system;</span><br><span class="line">  s_event_handler_func handlers[BX_OS_EVENT_MAX];</span><br><span class="line">&#125; kSystemEventHandlers[] = &#123;</span><br><span class="line">  &#123;<span class="string">"windows"</span>,</span><br><span class="line">   &#123;(s_event_handler_func)windows::init,</span><br><span class="line">    (s_event_handler_func)windows::check_kernel_addr,</span><br><span class="line">    (s_event_handler_func)windows::check_user_addr,</span><br><span class="line">    (s_event_handler_func)windows::fill_cid,	<span class="comment">// 获取线程环境块TEB，读取进程/线程ID</span></span><br><span class="line">    (s_event_handler_func)windows::fill_info,	<span class="comment">// 基于config.txt中配置的进线程结构offset去读取进线程信息，包括进程文件名、创建时间、栈回溯等信息</span></span><br><span class="line">    (s_event_handler_func)<span class="literal">NULL</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="string">"linux"</span>,</span><br><span class="line">   &#123;(s_event_handler_func)linux::init,</span><br><span class="line">    (s_event_handler_func)linux::check_kernel_addr,</span><br><span class="line">    (s_event_handler_func)linux::check_user_addr,</span><br><span class="line">    (s_event_handler_func)linux::fill_cid,</span><br><span class="line">    (s_event_handler_func)linux::fill_info,</span><br><span class="line">    (s_event_handler_func)<span class="literal">NULL</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="string">"freebsd"</span>,</span><br><span class="line">   &#123;(s_event_handler_func)freebsd::init,</span><br><span class="line">    (s_event_handler_func)freebsd::check_kernel_addr,</span><br><span class="line">    (s_event_handler_func)freebsd::check_user_addr,</span><br><span class="line">    (s_event_handler_func)freebsd::fill_cid,</span><br><span class="line">    (s_event_handler_func)freebsd::fill_info,</span><br><span class="line">    (s_event_handler_func)freebsd::instr_before_execution&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="string">"openbsd"</span>,</span><br><span class="line">   &#123;(s_event_handler_func)openbsd::init,</span><br><span class="line">    (s_event_handler_func)openbsd::check_kernel_addr,</span><br><span class="line">    (s_event_handler_func)openbsd::check_user_addr,</span><br><span class="line">    (s_event_handler_func)openbsd::fill_cid,</span><br><span class="line">    (s_event_handler_func)openbsd::fill_info,</span><br><span class="line">    (s_event_handler_func)openbsd::instr_before_execution&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="literal">NULL</span>, &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后就是输出记录的信息，比如作者发现的CVE-2018-0894漏洞信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">------------------------------ found uninit-copy of address fffff8a000a63010</span><br><span class="line"></span><br><span class="line">[pid/tid: 000001a0/000001a4] &#123;     wininit.exe&#125;</span><br><span class="line">       COPY of fffff8a000a63010 ---&gt; 1afab8 (64 bytes), pc = fffff80002698600</span><br><span class="line">       [                             mov r11, rcx ]</span><br><span class="line">Allocation origin: 0xfffff80002a11101</span><br><span class="line">                   (ntoskrnl.exe!IopQueryNameInternal+00000071)</span><br><span class="line">--- Shadow memory:</span><br><span class="line">00000000: 00 00 00 00 ff ff ff ff 00 00 00 00 00 00 00 00 ................</span><br><span class="line">00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</span><br><span class="line">00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</span><br><span class="line">00000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</span><br><span class="line">--- Actual memory:</span><br><span class="line">00000000: 2e 00 30 00 aa aa aa aa 20 30 a6 00 a0 f8 ff ff ..0..... 0......</span><br><span class="line">00000010: 5c 00 44 00 65 00 76 00 69 00 63 00 65 00 5c 00 \.D.e.v.i.c.e.\.</span><br><span class="line">00000020: 48 00 61 00 72 00 64 00 64 00 69 00 73 00 6b 00 H.a.r.d.d.i.s.k.</span><br><span class="line">00000030: 56 00 6f 00 6c 00 75 00 6d 00 65 00 32 00 00 00 V.o.l.u.m.e.2...</span><br><span class="line">--- Stack trace:</span><br><span class="line"> #0  0xfffff80002698600 (ntoskrnl.exe!memmove+00000000)</span><br><span class="line"> #1  0xfffff80002a11319 (ntoskrnl.exe!IopQueryNameInternal+00000289)</span><br><span class="line"> #2  0xfffff800028d4426 (ntoskrnl.exe!IopQueryName+00000026)</span><br><span class="line"> #3  0xfffff800028e8fa8 (ntoskrnl.exe!ObpQueryNameString+000000b0)</span><br><span class="line"> #4  0xfffff8000291313b (ntoskrnl.exe!NtQueryVirtualMemory+000005fb)</span><br><span class="line"> #5  0xfffff800026b9283 (ntoskrnl.exe!KiSystemServiceCopyEnd+00000013)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/12/01/bochspwn1/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/bochspwn/">bochspwn</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-24T02:09:41.000Z"><a href="/2018/11/24/杀软之殇/">2018-11-24</a></time>
      
      
  
    <h1 class="title"><a href="/2018/11/24/杀软之殇/">从杀软之殇谈产品</a></h1>
  

    </header>
    <div class="entry">
      
        <p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxixl44cx8j30zk0i2tyn.jpg" alt="百度"></p>
<p>前几天，百度杀毒、百度卫士宣布停止服务，祭出“百度杀毒感谢一路有你”的殇曲，就此终结！</p>
<p>PC杀毒软件的历史已经有35年，但在这移动互联网的时代，问津者能有几人呢？</p>
<p>今天就此事聊聊安全产品和安全从业人员。</p>
<h4 id="面向系统的产品"><a href="#面向系统的产品" class="headerlink" title="面向系统的产品"></a>面向系统的产品</h4><p>杀毒软件的出现就是弥补系统自身安全能力的不足，算是面向系统的安全产品，不仅是PC，Android上也是如此。</p>
<p>当年Android病毒那么严重，第一款Android主动防御软件LBE诞生时也是风光无限，甚至后面还利用系统漏洞作防御。</p>
<p>再看看现在，随着Windows系统自主安全能力以及自家杀软Windows Defender的不断完善，并且提供给杀软的接口越来越少，权限越来越集中管理，使得PC杀软越来越无用武之地，甚至曾经的头牌杀软已沦为流氓软件。</p>
<p>而这几年Google在Android安全上的投入也是非常大，整个系统的安全性相比前几年提升很大，他们家的chrome也曾在pwn2own黑客大赛幸存过几年，虽然今年被破了。</p>
<p>以前iOS截图后是不能直接分享的，然后就有一些软件直接提供截图后的分享功能，但是现在苹果自己在iOS上做了，如果软件还保留原分享功能，就成为一种干扰，有些软件就又不得不去掉：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fxj1m5l2w9j30cc0m0adq.jpg" alt="image-20181124123301131"></p>
<p>所以，<strong>凡是面向系统的产品，自系统厂商打算自己做时，就没你啥事了，无论是现今的PC，还是未来的移动端，均是如此。</strong></p>
<h4 id="面向业务的产品"><a href="#面向业务的产品" class="headerlink" title="面向业务的产品"></a>面向业务的产品</h4><p>以前，很多企业为了维护业务安全，都是从安全公司买服务或产品。</p>
<p>后来，随着企业的壮大，很多安全工作都企业自己做，自己开发扫描器、防火墙等等，然后各安全公司就开始被收购，乙方安全人员开始向甲方流动。</p>
<p>再后来，企业内部的业务部门也逐渐壮大，很多业务也开始自己做安全，他们也怕被安全部门捅漏洞丢面子，一些容易做的安全产品会被优先替代掉，一些需要长期投入并维护的安全产品，就得看业务部门是否有此人力，有些安全产品没有多年的积累一时也是无法替代的。与此同时，一些安全部门人员开始向业务部门流动。</p>
<p>所以，<strong>凡是面向业务的产品，自业务打算自己做时，就没你啥事了</strong>。</p>
<h4 id="面向人的产品"><a href="#面向人的产品" class="headerlink" title="面向人的产品"></a>面向人的产品</h4><p>人，可以分为商户（2B）与用户（2C），比如阿里就是典型的2B基因，腾讯就是典型的2C基因，虽然他们各自都不信这邪。正如当年阿里做来往，腾讯做拍拍一般，结局都是相当地凄惨。</p>
<p>杀软2C的道路基本已经凉凉的，但是2B之路还有点残羹剩饭，尤其是天朝机构，出于国家安全考虑，在抵制国外安全产品的同时，就需要国产安全产品替代。所以现在很多国内杀软都是逐步转向做2B业务，但肯定都是不如从前了。</p>
<p>人总有各种各样的需求，面对人的产品就是为了解决这些需求。比如人与人的沟通，以前飞鸽传书、快马加急，到现在的电话短信、微信视频等方式，需求亘古不变，只是产品在进化，在被另一种更高效、更低成本的产品替代。</p>
<p>所以，<strong>面向人的产品，产品要解决的需求形态可能长期存在，但产品终会被更高效、更低成本的产品替代</strong>。</p>
<h4 id="安全人员的生存之道"><a href="#安全人员的生存之道" class="headerlink" title="安全人员的生存之道"></a>安全人员的生存之道</h4><p>最近一年，在微信群里，仍然还有一些做Windows病毒分析的同学，还在聊Windows病毒，看着都觉得无力。如果是结合漏洞的病毒样本分析，还可以高谈APT混口饭吃，而其它类型的病毒都已经没什么市场了。</p>
<p>从一方面讲，移动时代不求思变转型的安全人员，有时也挺惨的，杀软产品不做了，这帮开发和分析人员又该何去何从。</p>
<p>就连招二进制安全的，很多人只会windows平台，不懂移动端，经常无法满足业务安全需求。当然，如果是深入Windows系统漏洞攻防的，那现在还是相当有市场的。</p>
<p>杀软这事也只是系统自身进化导致的，如果是系统颠覆的，如Android灭掉了Symbian，一身超神的塞班技能也无济于事。</p>
<p>我现在特别希望Android被新系统颠覆，所有安全人员又打回同一起跑线，重新开始研究新系统的漏洞攻防。当年虽赶上Android安全，但只搞了应用安全，没有深入系统安全，后来上车晚了，还是觉悟不够。</p>
<p>所以，安全人员还是得居安思危，不然哪天就真没饭吃了。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/11/24/杀软之殇/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/随笔杂谈/">随笔杂谈</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-18T09:47:02.000Z"><a href="/2018/11/18/读《态度》/">2018-11-18</a></time>
      
      
  
    <h1 class="title"><a href="/2018/11/18/读《态度》/">读《态度》</a></h1>
  

    </header>
    <div class="entry">
      
        <p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxcenoinw2j307009nta1.jpg" alt="image-20181118184524117"></p>
<p>《态度》是吴军在今年新出的书籍，是他写给女儿的40封家书。第一次读吴军的书是《见识》，读完觉得不错，因此这次“双十一”买了好几本他写的书，包括《浪潮之颠》、《大学之路》。</p>
<p>在新书中，主要分6部分来讲，分别讲了一些做人做事的原则、对待金钱和人际关系的态度、还有学习和人生哲学的一些观点。</p>
<h4 id="关于教育"><a href="#关于教育" class="headerlink" title="关于教育"></a>关于教育</h4><p>作者说”教育改变命运“，其实多数读书人应该都认同这一观点，他在书中讲述了3个观点：</p>
<ol>
<li><p><strong>”教育改变命运“已成为全世界大部分国家的共识</strong></p>
<p>欧洲很早就意识到教育对人一生的帮助，所以很早就开始兴办免费教育，让交不起学费的贫家子弟都可以到”官办“学校读书，牛顿就是靠这种免费的公立教育完成中学学业，进入剑桥大学的。很多来自中国农村的贫穷人家，为了摆脱贫穷，让自己子女接受良好的教育，通过一代人的努力摆脱贫穷，改变命运。</p>
</li>
<li><p><strong>衣食无忧的富家子弟也有必要接受教育</strong></p>
<p>中国著名作家吴晓波，就是那个写了《腾讯传》的人，调查了早期在股市上发财的几十人，发现除了一两个之外，其他人的结局无一例外都很惨，有破产的，有坐牢的，有被仇家杀的，有正在被追杀的。这些人都有两个共同点：第一，敢于冒险；第二，受教育水平低，最高中学学历。因此，他们在有了钱之后，没有更高的理想和追求。</p>
<p>【PS】：在中国，尤其是农村，一些没接受过多少教育的暴发户，有时会对年轻人或读书人说：“读书没有用的，你读那么多书赚的还不是没我多”！如果此时你对他说：“让你的孩子退学吧！“，估计他就没话了。还有一些在外工作多年的人，包括腾讯人，有时过年同学聚会，发现一些曾经读书不好或者辍学的老同学现在混得相当不错，比自己好太多的时候，通常都会反问自己：“读那么多书真的有用吗“？这种情况都是”幸存者偏差“的认识而已（顺便给大家推荐另一本书《思考，快与慢》，里面就讲了很多这种思考或认识的陷阱）。记得，腾讯内部论坛就有人发过这样感慨。</p>
</li>
<li><p><strong>对退学创业的误解</strong></p>
<p>互联网行业的退学创业代表主要有5人：比尔盖茨、乔布斯、佩奇、布林，以及扎克伯格。佩奇和布林是进入斯坦福读博士之前退学的，盖茨和扎克伯格情况类似，人家都是上过哈佛的，同样比绝大部分年轻人都出色，并接受过良好的教育，而且他们都是创业成功之后才退学的。乔布斯是因为不忍花父母的钱才没有读大学的，但至少是在斯坦福大学接受过教育的，如果他来自一个相对富有的家庭，或许会读完大学。</p>
</li>
</ol>
<p>####关于格局</p>
<p>决策时格局要大，做事时境界要高。用作者通俗一点的话来讲，就是要长远考虑，尽可能往最好的目标努力。</p>
<p>书中举例几个MIT和哈佛毕业生组成的创业团队，他们打算做高频交易（在股市中通过快速操作以赚取低买高卖时差价）的创业项目，作者认为他们都是非常聪明的人，但做事的格局不大，因为这赚不到大钱，属于小打小闹，而且这事仅是提高股市交易量，并无其它意义，对世界更不可能产生任何重大影响，而且这件事的公司已经很多了。</p>
<p>这种看似只赚不赔的高频交易公司为何做不到像Google、Apple那样赚更多钱呢？因为前者以改变世界为目的，后者以赚小钱、小富即安为目的。</p>
<p>很多亚裔家长一直在纠结孩子上名校是否有用？作者对此的观点是，如果格局提升不上去，上了也没有用，还达不到谷歌员工的平均水平。</p>
<h4 id="关于贫穷"><a href="#关于贫穷" class="headerlink" title="关于贫穷"></a>关于贫穷</h4><p>一个生于富有家庭的孩子不怕别人说他穷的，而一个贫家子弟通常反而怕别人说他穷，看不起他。卖肾买iPhone的人，一定是贫家子弟，怕别人说他穷。于是，很多穷人最后还是选择与穷人，甚至比自己穷的人为伍，成绩差的孩子还是选择扎堆一块玩。久而久之，那些人就无法摆脱原属阶层了。</p>
<p>大家常说：”物以类聚，人以群分“，因为这样对人来说，交际成本是最低的，也是最舒适的方式。一般人都不太愿意跳出自己的舒适区，去尝试更有难度且有助提升自我的挑战。</p>
<p>不管贫穷与否，如果事情做不好，那么你所处的地位可能与贫穷无异。通常情况下，人的心理能否接受自己不如别人，在可能会被别人嘲笑的情况下，是否还能努力往前走，直到改变自己的状态，这就是一种考验，与走出贫困差不多。</p>
<p>其实多数人都知道，要多向学习好的、能力强的人为伍，这些道理小学老师都经常说。但有时要去向比自己牛逼的人学习请教，也是需要一点勇气，以及改变自我的努力和决心。</p>
<h4 id="关于投资"><a href="#关于投资" class="headerlink" title="关于投资"></a>关于投资</h4><p>作者在书中挺推荐买标准普尔500指数，还让他女儿拿1/3的钱直接购买标普500指数ETF，每过两三个月就继续定投，不管涨跌。说实话，我也没关注这指数，今天赶紧加个关注先。</p>
<p>作者对投资给出了4条建议：</p>
<ol>
<li><p><strong>永远不要觉得自己能够打败市场</strong></p>
<p>我觉得下面这张图已经足够说明一切了，最近在微信和朋友圈上传得挺火的。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fxcfh8tjvlj307z0cz77v.jpg" alt="image-20181118191352193"></p>
</li>
<li><p><strong>对市场要有信心</strong></p>
</li>
</ol>
<p>作者说，股市有涨有跌，但要相信股市在较长的时间里是往上走的。</p>
<p>我曾经对腾讯700也是迷之自信，但你看看现在，这一年都跌成啥样了，当然如果你说再等个一两年，那应该还是涨的，看谁命长了。还好作者后面补了个第3点。</p>
<ol>
<li><strong>虽然股市在下跌后总会涨回来，但是单一股票未必。</strong></li>
</ol>
<p>在2000年股价到达顶点的英特尔和思科，今天的股价不足当年的1/4，而且可能永远没有机会回到当时的峰值了。也就是说，投资单一的股票，即使遇到明星公司，也未必能长期赚钱。</p>
<ol>
<li><strong>时间是你的朋友，而时机不是。</strong></li>
</ol>
<p>投资要有耐心，不要急于求成。聪明的投资人永远在股市上投资，而不是试图投机挑选最低点和最高点。因此，走出坏运气的关键是耐心，让时间成为我们的朋友。</p>
<p>除以上建议之外，作者还给出了3条禁忌：</p>
<ol>
<li><p><strong>不要进行过于冒险，会导致来顶之灾的投资</strong></p>
<p>比如做空股票和使用杠杆投资，你们再回头看看“格雷厄姆的微笑”吧！</p>
</li>
<li><p><strong>不要进行自己不懂的投资</strong></p>
<p>拿自己的短处和别人的长处比，胜算微乎其微。同时，你看不懂的投资里面常常有很多陷阱。</p>
</li>
<li><p><strong>不要被那些所谓的失去了的投机机会乱了方寸</strong></p>
<p>经常有人说：”如果我当初买了比特币，今天能赚100倍“。这种话是没有意义的，如同中彩票一般，是运气，遇不上，也不必在意，因为人生的机会还有很多。</p>
</li>
</ol>
<h4 id="关于友情"><a href="#关于友情" class="headerlink" title="关于友情"></a>关于友情</h4><p>作者在书中讲到一个在腾讯的经历，大家感受下，其它就不啰嗦了：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxcfyq7yg6j312k0u04go.jpg" alt="IMG_6440"></p>
<h4 id="关于交际"><a href="#关于交际" class="headerlink" title="关于交际"></a>关于交际</h4><p>与我们接触的人当中，可以分为4种：</p>
<ol>
<li>与自己关系好，能力强；</li>
<li>与自己关系好，能力有限；</li>
<li>并非自己朋友，但能力强；</li>
<li>与自己关系不好，能力不强。</li>
</ol>
<p>第1种好办，第4种交集不多，可以忽略，所以为人处世方面，我们需要比较留意的第2和第3种人。</p>
<p>对于这些人，我们必须理性对待，避免依据个人喜好来判断人和事：符合自己喜好的人，无论他们做什么都觉得好；不符合自己喜好的人，无论他们做什么都要挑毛病。</p>
<p>比如特朗普，很多人讨厌他，其实我也讨厌他，然后就有很多人对他做的任何事都持反对意见，无论对错，这就有点失去理想了。</p>
<p>在社会上，个人生活和事业有时是需要他人的支持和帮助，需要我们能够团结大多数人，把事情做好。</p>
<h4 id="关于拒绝"><a href="#关于拒绝" class="headerlink" title="关于拒绝"></a>关于拒绝</h4><p>作者举例说曾有朋友找他帮忙，就是帮个孩子联系谷歌或者腾讯的实习机会，但看了孩子材料之后就直接回绝了。那朋友也表示理解，就没有再提此事。</p>
<p>这种事太常见了，尤其是在腾讯这类公司，很多人会找过来帮忙找个工作之类，现在基本每次回家都有人找我。以前有人让我帮忙投简历，我一般都直接帮投了，即使有些简历或者学历问题，基本都拿不到面试机会的，我也帮忙投了，所以在公司那个”伯乐“平台上，结果全是拒绝的。后来，我学聪明了，不再当”老好人“。一些简历有问题，有明显水平不行的，我都委婉地回绝掉。一方面，投了也是白投，另一方面HR又不傻，我老帮人投这类简历，别人还会觉得我看人的水平太次太有问题了。</p>
<p>对于别人请帮忙的事，作者总结出4点，按不同情况采取不同的方法处理：</p>
<ol>
<li>能力不及，不能帮上忙，直接在第一时间委婉拒绝。</li>
<li>能帮上忙，但是自己代价太大，不想帮的，就不要勉强自己，但也要及早通知对方。</li>
<li>不论多困难都愿意帮，而且极有可能办成，这时就答应对方，然后全力去做。</li>
<li>虽然愿意帮，但有可能帮上，也可能帮不上，这时要将实际情况说明，千万不要轻易许诺。</li>
</ol>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>这书整体上我觉得还不错，虽然有些是对中学生或大学生说的道理，很多事情自己经历过也都明白，但也有一些适合不同年龄段的人学习的知识点，所以还是推荐阅读。</p>
<p>喜欢吴军写的书，并非崇拜对方，而他写的书确实很好，也很用心。在这种浮躁的社会，出书也不容易，写好书更不容易，自己出过书的人应该更有体会。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/11/18/读《态度》/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/随笔杂谈/">随笔杂谈</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/读书笔记/">读书笔记</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-10T08:17:37.000Z"><a href="/2018/11/10/读《风格感觉：21世纪写作指南》/">2018-11-10</a></time>
      
      
  
    <h1 class="title"><a href="/2018/11/10/读《风格感觉：21世纪写作指南》/">读《风格感觉：21世纪写作指南》</a></h1>
  

    </header>
    <div class="entry">
      
        <p>1、节俭使用元话语（语句中标示话语结构的标记语言，即用来提醒读者应该注意什么），可以用提问代替元话语，比如：</p>
<blockquote>
<p>【改前】：这一章讨论引起名字流行程度上升和下降的因素。</p>
<p>【改后】：一个名字流行或不流行的原因是什么？</p>
</blockquote>
<p>2、放弃专家腔、更自然地对话</p>
<blockquote>
<p>【改前】：近年来，越来越多的心理学家和语言学家将注意力转向儿童语言习得的问题。本文将评述这一过程近年来的研究。</p>
<p>【改后】：小孩子不用专门上课，就能获得说一门语言的能力。他们怎么做到的？</p>
</blockquote>
<p>3、写作清晰有力，少用模糊词汇</p>
<blockquote>
<p>【改前】：杰克是个诚实的人。</p>
<p>【改后】：杰克是个<code>特别</code>诚实的人。</p>
</blockquote>
<p>加了“特别”反而让人产生困惑，甚至以为说的是反话，所以少用“非常”、“十分”、“特别”这种过犹不及的强调词。</p>
<p>4、少用抽象词，比如“xx性”、“xx观”、“xx力”，这种特别容易出现在工作中，俗称“官僚体”，腾讯内部就有一堆此类名词（闭环、打法、自控力、大局观、专注度……）</p>
<p>5、去掉僵尸名词：比如“做出确认”变成“确认”、“做出辞职的决定”变成“决定辞职”。</p>
<p>6、采用主动和互动风格，即站在读者角度或者自己主动的角度。</p>
<blockquote>
<p>【改前】：我们很高兴地宣布，本实验室的新设施将对外开放，随时准备承接各类脑科学实验。</p>
<p>【改后】：你将有机会使用本实验室，来做你的脑科学实验。</p>
</blockquote>
<p>7、【有序地称呼反复出现的事物】避免读者过多思考，免得他们需要思考是否为新事物</p>
<blockquote>
<p>一个<code>英国人</code>、一个<code>法国人</code>和一个<code>犹太人</code>坐在一起，这个<code>英国人</code>说……，这个<code>法国人</code>说……，这个<code>犹太人</code>说……</p>
</blockquote>
<p>少用他/她/它去代替前面说过的人物事等，减少读者疑惑和思考，避免产生歧义，比如：</p>
<blockquote>
<p>愧疚、复仇和苦痛会从感情上毁掉你和你的孩子。<code>你</code>必须摆脱他们。</p>
</blockquote>
<p>上面的<code>你</code>是摆脱你的孩子，还是摆脱愧疚、复仇和苦痛？</p>
<p>8、避免使用过多的连接词，否则文章就会变得臃肿不堪，比如下句中的<code>因为</code>就是多余的，因为前面的“原因”已经暗示我们正在做出解释：</p>
<blockquote>
<p>太多人生活在黑暗之中的原因是<code>因为</code>他们想那样生活。</p>
</blockquote>
<p>9、【谨慎地运用否定】正如克林顿辩解道“我没有和那个女人发生过性关系”的时候，并没有使各种传言平息下来，有时甚至起到“此地无银三百两“的反作用。</p>
<p>10、正确的写作用法只是促成良好写作最小的因素，其重要性远远比不过保持连贯性、使用古典风格、克服知识的诅咒，更不用说在智力上维护勤恳了。假如真的希望提高写作质量，或者怒斥他人的文章，最需要关注的不是那些语法规则，而是那些支配批判性思考和发现事实的规则：</p>
<p>​    a. 查资料</p>
<p>​    b.确保论证有理有据</p>
<p>​    c. 不要把轶事或个人经历当作世界的常态，避免把特殊个例当作显著现象</p>
<p>​    d. 谨防虚假的二分法：把复杂问题化为两种思想之间的战争，几乎无法帮助我们增进理解</p>
<p>​    e.论证应当基于理性，而非个人。即“不要证明自己对，而要弄清什么是对的”</p>
<p>最后说一句最重要的话：</p>
<p><strong>热文或畅销书之所以流行，关键在于其内容，而非华丽的辞藻文法。</strong></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/11/10/读《风格感觉：21世纪写作指南》/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/随笔杂谈/">随笔杂谈</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-11-10T00:53:52.000Z"><a href="/2018/11/10/我的挑书手段/">2018-11-10</a></time>
      
      
  
    <h1 class="title"><a href="/2018/11/10/我的挑书手段/">我的挑书手段</a></h1>
  

    </header>
    <div class="entry">
      
        <p>双十一，一年一度的”屯书日“又到了。</p>
<p>鄙人生平无其它购物嗜好，唯有购书。</p>
<p>在电子书横行的时代，各类读书应用都在崛起，比如”微信读书“、”QQ阅读“、”掌阅“等，个人习惯用微信读书，因为有社交好友的阅读推荐，以及公司送的读书券，所以基本也都是免费的，这个才是重点。</p>
<p>对于懒人，也有听书应用，比如”懒人听书“、”喜马拉雅“，特别适合听小说、历史人文，之前我就在上面听过《明朝那些事儿》、《盗墓笔记》等，特别是一些小说类的配音，如电影一般，甚是精彩声动。</p>
<p>开篇聊完，该说说”挑书”这件事儿了……</p>
<p>首先，对于非技术书，如果在上述读书app中有免费的，一般我不会去买实体书，直接在app上翻来看看，有兴趣就继续，没兴趣就结束了。</p>
<p>所以，这里所说的挑书，挑的是技术书以及无电子版的非技术书，或者其它想收藏的经典书籍（如书帖、史书、经管心理名著等等）。</p>
<h4 id="挑书第一式：查作者翻目录"><a href="#挑书第一式：查作者翻目录" class="headerlink" title="挑书第一式：查作者翻目录"></a>挑书第一式：查作者翻目录</h4><p>翻开当当网信息安全书籍总榜，在前3名，永远有一本书占其中，书名永远是《黑客xx从入门到精通》，而且还是个系列，好多本，也不得不承认，越初级越入门，越受欢迎，毕竟菜鸟永远比专业人士多……</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fx2pvzdgcfj30q806iq5z.jpg" alt="image-20181110093819437"></p>
<p>挑书第一眼，自然是作者与目录，但对它们的判断，又常常要求读者具备一定的专业知识，因为：</p>
<blockquote>
<p><strong>“只有具备犯罪能力的人才能洞察他人的犯罪行为。”</strong></p>
</blockquote>
<p>先看作者，经常署名“xx工作室”，也有个人，此时都可以查看他们出过的书，对比各书目录，经常可以发现“换汤不换药”的行为，把旧书内容重新包装进新书再出版。</p>
<p>有时出版社编辑也会找我帮忙评价下某些新书目录，我就经常这么搞，偶而就会发现存在这种情况。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx2qf148i7j30d20f612a.jpg" alt="image-20181110095640534"></p>
<p>现在很多书籍都可以在线试读了，也一种不错的挑书方式。</p>
<h4 id="挑书第二式：利用工具查价"><a href="#挑书第二式：利用工具查价" class="headerlink" title="挑书第二式：利用工具查价"></a>挑书第二式：利用工具查价</h4><p>每到购物节，各网站都会推出“满多少减多少”的优惠，但有时查下历史价格趋势会发现，都是先抬高价格再打折的。</p>
<p>对于这种情况都一些工具可以查询，如果是在电脑上可以用“油猴“脚本：购物党自动比价工具：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fx2qp7xqnwj30zg0azn24.jpg" alt="image-20181110100630299"></p>
<p>如果是手机上，可以使用”慢慢买“、”历史价值查询“，比如京东《态度》这本书，昨天就从32.5抬高到59：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fx2qsszf40j309a0g5tb5.jpg" alt="image-20181110100956404"></p>
<h4 id="挑书第三式：看评价"><a href="#挑书第三式：看评价" class="headerlink" title="挑书第三式：看评价"></a>挑书第三式：看评价</h4><p>购物网站上面都有评价可以看，还有豆瓣读书上，都可以看到一些书籍的评价，作为自己的一些参考。虽然豆瓣读书的评分不如电影那般准确，但评语还是可以参考的。</p>
<p>还有网上也有一些推荐书籍的文章，经典的比如”C语言之四书五经“、“Linux内核学习四库全书”，还有最近左耳朵耗子在微博上推荐的“程序员必读经典书籍”，都是可以借鉴参考的。</p>
<p>这些文章网上都有，大家自行搜索，对于信息安全从业人员，之前我也列了个书单“信息安全从业者书单推荐”：<a href="https://github.com/riusksk/secbook，好坏自行判断，毕竟不同人对同一本书的看法也是不一样的。" target="_blank" rel="external">https://github.com/riusksk/secbook，好坏自行判断，毕竟不同人对同一本书的看法也是不一样的。</a></p>
<h4 id="挑书第四式：预估对个人的实用价值"><a href="#挑书第四式：预估对个人的实用价值" class="headerlink" title="挑书第四式：预估对个人的实用价值"></a>挑书第四式：预估对个人的实用价值</h4><p>“买书如山倒，看书如抽丝”是多数人的真实写照，所以有时我也特别能理解女生为何喜欢整天买化妆品衣服包包之类的。对于这种情况，我一般这样选择：</p>
<ul>
<li><p>在未来一年自己用不上的技术知识，不买相关书籍。</p>
</li>
<li><p>未来一年可能过时或淘汰的技术知识（比如Flash、塞班等），不买相关书籍</p>
</li>
<li><p>挑选与当前自身能力要求相近或高一点的书籍，至少能看懂半本书的，当年初学二进制逆向，看《网络渗透技术》一书就跟天书一般，没几年的技术功底积累，也根本看不懂此书</p>
</li>
<li>可能绝版的好书，也可考虑提前购买，即使当前看不懂，还说《网络渗透技术》这书，后来我在淘宝双倍价购买打印版了，现在china-pub上也可以双倍价购买此书，不过封面已换</li>
</ul>
<h4 id="挑书第五式：打铁仍需自身硬"><a href="#挑书第五式：打铁仍需自身硬" class="headerlink" title="挑书第五式：打铁仍需自身硬"></a>挑书第五式：打铁仍需自身硬</h4><p>遥想当年，我看的第一本安全书籍叫《黑客入门》，当时挑书的标准是：必须带有“黑客”两个字，否则不看。</p>
<p>过一段时间，发现这些书籍对提高技术并没有什么作用，然后开始找大学计算机课程开始从基础学起。</p>
<p>这个转折点，要从《深入理解计算机系统》开始，然后又开始学汇编、C/C++、数据结构与算法等等基本课。</p>
<p>当自己积累得越来越多的时候，能看懂的书就越多，对技术书籍的好坏判断，自然就有自己的评判标准。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fx2rvlwgu4j309j0b4dhn.jpg" alt="WX20180707-203543"></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/11/10/我的挑书手段/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/随笔杂谈/">随笔杂谈</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-14T01:48:40.000Z"><a href="/2018/10/14/honggfuzz5/">2018-10-14</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/14/honggfuzz5/">honggfuzz漏洞挖掘技术深究系列（5）—— Intel Processor Trace</a></h1>
  

    </header>
    <div class="entry">
      
        <p>对于闭源程序的反馈驱动Fuzzing，通常有3种方式：</p>
<ul>
<li><p>二进制插桩：使用Pin或DynamoRIO动态插桩监控代码覆盖率，比如winafl</p>
</li>
<li><p>虚拟化技术：使用Qemu或Boch等虚拟化技术实现应用层和内核层的代码覆盖率监控，比如afl、bochpwn</p>
</li>
<li><p>硬件级技术：使用Intel Processor Trace（PT）技术，比如honggfuzz</p>
</li>
</ul>
<h4 id="Intel-PT"><a href="#Intel-PT" class="headerlink" title="Intel PT"></a>Intel PT</h4><p>Intel® Processor Trace (Intel® PT) 是在i5/i7 5000以上型号上加入的功能，由于它是硬件级的特性，相比Qemu或Boch，在性能上和代码工作量会占有一定优势。在Linux上可以通过perf来使用PT，可以先简单看是否支持PT：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查看是否支持PT:</span><br><span class="line">ls /sys/devices/intel_pt/format</span><br><span class="line"></span><br><span class="line">追踪程序执行：</span><br><span class="line">perf record -e intel_pt// program</span><br></pre></td></tr></table></figure>
<p>也可以使用开源工具<a href="https://github.com/andikleen/simple-pt" target="_blank" rel="external">simple-pt</a>中的ptfeature命令行工具来检测:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ptfeature pt</span><br><span class="line">Supports PT</span><br></pre></td></tr></table></figure>
<p>最新版GDB也支持pt功能了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gdb program</span><br><span class="line">start</span><br><span class="line">record btrace pt</span><br><span class="line">cont</span><br><span class="line"></span><br><span class="line">record instruction-history /m	# show instructions</span><br><span class="line">record function-history		# show functions executed</span><br></pre></td></tr></table></figure>
<h4 id="honggfuzz-perf-event-open"><a href="#honggfuzz-perf-event-open" class="headerlink" title="honggfuzz perf_event_open"></a>honggfuzz perf_event_open</h4><p>在程序内通过<code>perf_event_open</code>（<a href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html）函数可以使用PT实现BB基本块的覆盖率追踪，传递给指定进程pid来实现监控：" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/perf_event_open.2.html）函数可以使用PT实现BB基本块的覆盖率追踪，传递给指定进程pid来实现监控：</a></p>
<p><img src="http://riusksk.me/media/perf_event_open.png" alt=""></p>
<p>将返回的文件描述符传递给mmap映射为可读写的用户内存空间，以便从中读取PT记录的追踪数据：</p>
<p><img src="http://riusksk.me/media/mmapbuf.png" alt=""></p>
<p>PT记录的追踪数据采用压缩的二进制格式输出，每秒每个CPU都会持续记录并输出，由于是硬件记录的，最早自然是出现在内核空间，为了使用它，就需要将其导出到用户空间，即通过前面mmap方法映射到用户可写的内存空间，然后再去定位数据解码。PT导出的追踪数据被存储在一个叫<code>AUX space</code>的内存区域，它相对<code>perfMmapBuf</code>的偏移记录在<code>perf_event_mmap_page-&gt;aux_offset</code>，大小为<code>perf_event_mmap_page-&gt;aux_size</code>，上面代码的第二步<code>mmap</code>就是去映射<code>AUX space</code>。</p>
<p>接下来就是利用libpt来解码捕获到追踪数据，实现函数位于perf_ptAnalyzePkt中：</p>
<p><img src="http://riusksk.me/media/ptAnalyzePkt.png" alt=""></p>
<p>最后将执行到的BB基本块信息更新到feedback map，之后的实现步骤就跟本系列第1篇驱动反馈中所讲的一致。</p>
<p>跑起来的效果如下图：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fxr27bx6jnj30ks08245z.jpg" alt="image-20181201105755833"></p>
<p>到这里，关于《honggfuzz漏洞挖掘技术深究系列》的文章先暂告一段落了，它就相当于是自己的学习笔记，也可以留作日后查询。</p>
<p>本系列的其它文章如下：</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483746&amp;idx=1&amp;sn=9d0ff5e0bae65f9ca9dbea4cf74449c6&amp;chksm=fb04159acc739c8c36e0785e2ce9c3a202066c6cc39a9ce32fd0fc9dfeb348e860a82e29c9d6&amp;token=3421110&amp;lang=zh_CN#rd" target="_blank" rel="external">honggfuzz漏洞挖掘技术深究系列（1）——反馈驱动（Feedback-Driven）</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483780&amp;idx=1&amp;sn=8e634a1deb08006063156db60b1c1f77" target="_blank" rel="external">honggfuzz漏洞挖掘技术深究系列（2）—— Persistent Fuzzing</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483819&amp;idx=1&amp;sn=daed3baf16e1211d6d869183ba1680f4&amp;chksm=fb041553cc739c457d54494c99d1870488dfa76831fde40a351098b0fcfcdb9f716a473ba213&amp;token=3421110&amp;lang=zh_CN#rd" target="_blank" rel="external">honggfuzz漏洞挖掘技术深究系列（3）——Fuzz策略</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0MzgzNTU0Mw==&amp;mid=2247483828&amp;idx=1&amp;sn=e96241ce399781414db3ba556ce1f90d&amp;chksm=fb04154ccc739c5a12176eb7492e80abfd36e630193627ba140394e678e47ee2b0f1532516b1&amp;token=3421110&amp;lang=zh_CN#rd" target="_blank" rel="external">honggfuzz漏洞挖掘技术深究系列（4）—— 扩展Fuzzer</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/10/14/honggfuzz5/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/honggfuzz/">honggfuzz</a>, <a href="/tags/fuzz/">fuzz</a>, <a href="/tags/漏洞挖掘/">漏洞挖掘</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->


  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2018-10-02T01:35:52.000Z"><a href="/2018/10/02/honggfuzz4/">2018-10-02</a></time>
      
      
  
    <h1 class="title"><a href="/2018/10/02/honggfuzz4/">honggfuzz漏洞挖掘技术深究系列（4）—— 扩展Fuzzer</a></h1>
  

    </header>
    <div class="entry">
      
        <p>对于一些复合文件格式，如果只是单纯的暴力Fuzzing，会导致生成很多无法被解析的文件，因此需要对文件变异作一些定制化的工作，比如docx、doc等office复合文件，docx是个压缩包，doc是个OLE格式，如果fuzz docx自然需要将其zip解压，再针对感兴趣的文件作变异，对于doc最好是作文件格式解析，只对感兴趣的stream作文件变异，这样的fuzzing的有效性才会更高。</p>
<p>庆幸地是，honggfuzz提供<code>-c</code>参数用于扩展变异规则以代替原有变异方式，同时提供有<code>--pprocess_cmd</code>在原有的文件变异后再作处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--mutate_cmd|-c VALUE</span><br><span class="line">External command producing fuzz files (instead of internal mutators)</span><br><span class="line">--pprocess_cmd VALUE</span><br><span class="line">External command postprocessing files produced by internal mutators</span><br></pre></td></tr></table></figure>
<p><code>-c</code>功能比较有用，也是我用得比较多的，另一个<code>--pprocess_cmd</code>基本我没用过。</p>
<p>当你通过<code>-f</code>提供输入样本目录后，在fuzzing时，随机提取的文件会直接传递给<code>-c</code>参数指定的扩展命令作变异。</p>
<p>比如想针对某文件特定offset范围内的内容进行变异，下面是针对macOS/iOS字体文件中的虚拟指令作Fuzzing时写的脚本：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mmap</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">RANGE_START = <span class="number">0x16D8</span></span><br><span class="line">RANGE_END   = <span class="number">0x304D</span></span><br><span class="line">MIN_BYTES_TO_FLIP = <span class="number">1</span></span><br><span class="line">MAX_BYTES_TO_FLIP = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">".DS_Store"</span> <span class="keyword">in</span> sys.argv[<span class="number">1</span>]:</span><br><span class="line">    exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], <span class="string">"r+b"</span>) <span class="keyword">as</span> f:</span><br><span class="line">  mapped = mmap.mmap(f.fileno(), <span class="number">0</span>)</span><br><span class="line">  <span class="comment">#print "file size: 0x%x" % len(mapped)</span></span><br><span class="line">  bytes_to_flip = randint(MIN_BYTES_TO_FLIP, MAX_BYTES_TO_FLIP)</span><br><span class="line">  bytes_flipped = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> bytes_flipped &lt; bytes_to_flip:</span><br><span class="line">    byte_pos = randint(RANGE_START, RANGE_END)</span><br><span class="line">    <span class="comment">#print "byte_pos: 0x%x" %byte_pos </span></span><br><span class="line">    byte_new = chr(randint(<span class="number">0</span>, <span class="number">255</span>))</span><br><span class="line">    mapped[byte_pos] = byte_new</span><br><span class="line">    bytes_flipped += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  mapped.close()</span><br></pre></td></tr></table></figure>
<p>变异效果：</p>
<p><img src="http://riusksk.me/media/font_rangfuzz.png" alt=""></p>
<p>最后挖到一个TTF字体虚拟指令漏洞：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">orig file:</span><br><span class="line">2F90h: 00 3F C5 CD 2B 10 C1 10 DE 3F C5 【CD】 2B 10 C5 10</span><br><span class="line"></span><br><span class="line">poc file:</span><br><span class="line">2F90h: 00 3F C5 CD 2B 10 C1 10 DE 3F C5 【DD】 2B 10 C5 10</span><br><span class="line"></span><br><span class="line">glyf table -&gt; SimpleGlyf[] -&gt; Instructions(&apos;0xCD&apos; =&gt; ‘0xDD&apos;) -&gt; MDRP指令</span><br></pre></td></tr></table></figure>
<p>同样的，你也可以写个doc、docx等office文件格式解析并变异的扩展fuzzer，比如利用olefile库（但只支持修改同等大小不变的doc，要插入或删除需要自行实现），或者通过COM接口来实现操作。</p>
<p>比如之前有段时间doc中的公式编辑器存在很多漏洞，你就可以专门针对<code>Equation Native</code>流作fuzzing。</p>
<p>最后放两张图(riufuzz是自己对honggfuzz二次开发的版本，后面有机会再讲)：</p>
<p><img src="http://riusksk.me/media/olefuzz.jpeg" alt=""></p>
<p><img src="http://riusksk.me/media/doc_crash.jpg" alt=""></p>
<center><img src="http://riusksk.me/media/gzh.png" alt=""></center>





      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2018/10/02/honggfuzz4/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/honggfuzz/">honggfuzz</a>, <a href="/tags/fuzz/">fuzz</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>

  </div>
</article>

<!-- 

 -->



<nav id="pagination">
  
  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:riusksk.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2019/07/14/一些值得学习的Fuzzer开源项目/">一些值得学习的Fuzzer开源项目</a>
      </li>
    
      <li>
        <a href="/2019/06/29/Infiltrate2019议题学习/">Infiltrate2019议题学习</a>
      </li>
    
      <li>
        <a href="/2019/05/11/2019年哪些安全大会的议题值得学习/">2019年哪些安全大会的议题值得学习</a>
      </li>
    
      <li>
        <a href="/2019/05/03/读《一本小小的蓝色逻辑书》/">读《一本小小的蓝色逻辑书》：识别常见的逻辑漏洞</a>
      </li>
    
      <li>
        <a href="/2019/03/30/RSS-优秀的个人情报来源/">RSS: 优秀的个人情报来源</a>
      </li>
    
      <li>
        <a href="/2019/02/22/今年的OffensiveCon大会议题不错/">今年的OffensiveCon大会议题质量不错</a>
      </li>
    
      <li>
        <a href="/2019/02/02/winafl中基于插桩的覆盖率反馈原理/">winafl中基于插桩的覆盖率反馈原理</a>
      </li>
    
      <li>
        <a href="/2019/01/27/聊聊那些黑客小说/">聊聊那些黑客小说</a>
      </li>
    
      <li>
        <a href="/2019/01/12/安全研究者的自我修养（续）/">安全研究者的自我修养（续）</a>
      </li>
    
      <li>
        <a href="/2019/01/06/安全研究者的自我修养/">安全研究者的自我修养</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/技术分享/">技术分享</a><small>55</small></li>
  
    <li><a href="/categories/随笔杂谈/">随笔杂谈</a><small>25</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/0day/" style="font-size: 11.67px;">0day</a> <a href="/tags/ASLR/" style="font-size: 10px;">ASLR</a> <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/Apple/" style="font-size: 10px;">Apple</a> <a href="/tags/BlackHat/" style="font-size: 13.33px;">BlackHat</a> <a href="/tags/Bochspwn/" style="font-size: 10px;">Bochspwn</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/CVE/" style="font-size: 10px;">CVE</a> <a href="/tags/CanSecWest/" style="font-size: 11.67px;">CanSecWest</a> <a href="/tags/DEP/" style="font-size: 10px;">DEP</a> <a href="/tags/EAT/" style="font-size: 10px;">EAT</a> <a href="/tags/EMET/" style="font-size: 10px;">EMET</a> <a href="/tags/Flash/" style="font-size: 15px;">Flash</a> <a href="/tags/Fuzzer/" style="font-size: 10px;">Fuzzer</a> <a href="/tags/Fuzzing/" style="font-size: 11.67px;">Fuzzing</a> <a href="/tags/GS/" style="font-size: 10px;">GS</a> <a href="/tags/Hacking-Team/" style="font-size: 18.33px;">Hacking Team</a> <a href="/tags/Heap-Spray/" style="font-size: 10px;">Heap Spray</a> <a href="/tags/Hook/" style="font-size: 10px;">Hook</a> <a href="/tags/MemProt/" style="font-size: 10px;">MemProt</a> <a href="/tags/OSX/" style="font-size: 13.33px;">OSX</a> <a href="/tags/PHDays/" style="font-size: 10px;">PHDays</a> <a href="/tags/Perl/" style="font-size: 11.67px;">Perl</a> <a href="/tags/SafeSEH/" style="font-size: 10px;">SafeSEH</a> <a href="/tags/Shellcode/" style="font-size: 10px;">Shellcode</a> <a href="/tags/UAF/" style="font-size: 10px;">UAF</a> <a href="/tags/UXSS/" style="font-size: 10px;">UXSS</a> <a href="/tags/Windows/" style="font-size: 11.67px;">Windows</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/bochspwn/" style="font-size: 10px;">bochspwn</a> <a href="/tags/fuzz/" style="font-size: 13.33px;">fuzz</a> <a href="/tags/fuzzing/" style="font-size: 11.67px;">fuzzing</a> <a href="/tags/honggfuzz/" style="font-size: 16.67px;">honggfuzz</a> <a href="/tags/iOS/" style="font-size: 11.67px;">iOS</a> <a href="/tags/macOS/" style="font-size: 10px;">macOS</a> <a href="/tags/rootkit/" style="font-size: 11.67px;">rootkit</a> <a href="/tags/shellcode/" style="font-size: 10px;">shellcode</a> <a href="/tags/v8/" style="font-size: 10px;">v8</a> <a href="/tags/winafl/" style="font-size: 10px;">winafl</a> <a href="/tags/书籍/" style="font-size: 20px;">书籍</a> <a href="/tags/信息安全/" style="font-size: 10px;">信息安全</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/写作/" style="font-size: 10px;">写作</a> <a href="/tags/历史/" style="font-size: 10px;">历史</a> <a href="/tags/威胁建模/" style="font-size: 10px;">威胁建模</a> <a href="/tags/学历/" style="font-size: 10px;">学历</a> <a href="/tags/安全大会/" style="font-size: 10px;">安全大会</a> <a href="/tags/安全审计/" style="font-size: 11.67px;">安全审计</a> <a href="/tags/安全研究/" style="font-size: 11.67px;">安全研究</a> <a href="/tags/思维导图/" style="font-size: 10px;">思维导图</a> <a href="/tags/恶意软件/" style="font-size: 11.67px;">恶意软件</a> <a href="/tags/打印机/" style="font-size: 10px;">打印机</a> <a href="/tags/攻防/" style="font-size: 10px;">攻防</a> <a href="/tags/溢出/" style="font-size: 10px;">溢出</a> <a href="/tags/漏洞/" style="font-size: 13.33px;">漏洞</a> <a href="/tags/漏洞挖掘/" style="font-size: 13.33px;">漏洞挖掘</a> <a href="/tags/监控取证/" style="font-size: 10px;">监控取证</a> <a href="/tags/程序员/" style="font-size: 10px;">程序员</a> <a href="/tags/编程/" style="font-size: 11.67px;">编程</a> <a href="/tags/编译原理/" style="font-size: 10px;">编译原理</a> <a href="/tags/职业/" style="font-size: 10px;">职业</a> <a href="/tags/虚拟机/" style="font-size: 10px;">虚拟机</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a> <a href="/tags/读书笔记/" style="font-size: 10px;">读书笔记</a> <a href="/tags/逻辑/" style="font-size: 10px;">逻辑</a> <a href="/tags/黑客/" style="font-size: 10px;">黑客</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2019 riusksk
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  & Hosted by <a href="http://github.com" target="_blank">GitHub</a>
  <!--<span id="busuanzi_container_site_pv" >
    ，本站总访问量<span id="busuanzi_value_site_pv" ></span>次
  </span>
  -->
  </p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>




<div id='bg'></div>
</body>
</html>